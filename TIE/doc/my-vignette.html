<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="18070" />

<meta name="date" content="2019-01-12" />

<title>Include all my work</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Include all my work</h1>
<h4 class="author"><em>18070</em></h4>
<h4 class="date"><em>2019-01-12</em></h4>



<div id="this-is-the-work-in-2018.9.14" class="section level2">
<h2>This is the work in 2018.9.14</h2>
<div id="assignment-description" class="section level3">
<h3>Assignment description</h3>
<p>Write a .Rmd file to implement at least three examples of different types in the above books (texts, numerical, tables, and figures)</p>
<p><em>example 1</em></p>
<p>this example is from page 5 from book “R for beginners”</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n =<span class="st"> </span><span class="dv">3</span><span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>)
n
<span class="co">#&gt; [1] 2.373546</span></code></pre></div>
<p>rnorm(1) generates a random number which is a Gaussian random number, so the result depends on the computer.</p>
<p><em>example 2</em></p>
<p>this example is from page 10 from the book</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> &quot;Double quotes</span><span class="ch">\&quot;</span><span class="st"> delimitate R's strings&quot;</span>
x
<span class="co">#&gt; [1] &quot;Double quotes\&quot; delimitate R's strings&quot;</span>
<span class="kw">cat</span>(x)
<span class="co">#&gt; Double quotes&quot; delimitate R's strings</span></code></pre></div>
<p>this example reminds me of one bug I met when I read data from disk. I write something like the things below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data =<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;C:\Users\lenovo\Desktop\...&quot;</span>)</code></pre></div>
<p>But it cannot be compiled. I googled for solution. It turns out that I should add \ in every \, in this way, the R will take \ as \ but not something else.</p>
<p><em>example 3</em></p>
<p>I am quite confused with the word tables. In this text, I will think it as data frame.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a =<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">h =</span> <span class="kw">c</span>(<span class="dv">60</span>, <span class="dv">80</span>), <span class="dt">w =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">300</span>), <span class="dt">sex =</span> <span class="kw">c</span>(<span class="st">&quot;Male&quot;</span>, <span class="st">&quot;Female&quot;</span>))</code></pre></div>
<p>This funcionn will generate a dataframe, and the results will conclude every match of every attribute. And if you are worried that whether it is a dataframe you can check that like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(a)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre></div>
<p>And last I will plot a figure.</p>
<p><em>example 4</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>)
y =<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>)
<span class="kw">plot</span>(x,y)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Autually there are some details in the plot() function. But I think these can be learned when used.</p>
</div>
</div>
<div id="this-is-the-work-in-2018.9.21" class="section level2">
<h2>This is the work in 2018.9.21</h2>
<div id="assigment-3.5" class="section level3">
<h3>assigment 3.5</h3>
<p><em>Problem Discription</em> A discrete random variable X has probability mass function</p>
<table>
<thead>
<tr class="header">
<th>x</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>p(x)</td>
<td align="center">0.1</td>
<td align="center">0.2</td>
<td align="center">0.2</td>
<td align="center">0.2</td>
<td align="center">0.3</td>
</tr>
</tbody>
</table>
<p>Use the inverse transform method to geneate a random sample of size 1000 from the distribution of X. Construct a relateive frequency table and compare the empirical with the theoretical prbabilities. Repeat using the R sample funtion.</p>
<p><em>Answer</em></p>
<p><em>1.Using inverse transform method </em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">4</span>
p =<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>)<span class="op">/</span><span class="dv">10</span>
cp =<span class="st"> </span><span class="kw">cumsum</span>(p)
m =<span class="st"> </span><span class="fl">1e3</span>
r =<span class="st"> </span><span class="kw">numeric</span>(m)
r =<span class="st"> </span>x[<span class="kw">findInterval</span>(<span class="kw">runif</span>(m), cp)<span class="op">+</span><span class="dv">1</span>]
## construct a relative frequency table
<span class="kw">table</span>(r)<span class="op">/</span>m
<span class="co">#&gt; r</span>
<span class="co">#&gt;     0     1     2     3     4 </span>
<span class="co">#&gt; 0.097 0.199 0.223 0.178 0.303</span>
a =<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">table</span>(r))
## compare the empirical with the theretical probabilities
a<span class="op">/</span><span class="kw">sum</span>(a)<span class="op">/</span>p
<span class="co">#&gt; [1] 0.970 0.995 1.115 0.890 1.010</span></code></pre></div>
<p><em>2.repeating using the R sample function</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## repeat using the R sample function
b =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">4</span>, m, <span class="dt">prob =</span> p, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
table2 =<span class="st"> </span><span class="kw">table</span>(b)
<span class="co">#relative frequency table</span>
table2
<span class="co">#&gt; b</span>
<span class="co">#&gt;   0   1   2   3   4 </span>
<span class="co">#&gt; 100 198 204 176 322</span>
c =<span class="st"> </span><span class="kw">as.vector</span>(table2)
<span class="co"># compare</span>
c<span class="op">/</span><span class="kw">sum</span>(c)<span class="op">/</span>p
<span class="co">#&gt; [1] 1.000000 0.990000 1.020000 0.880000 1.073333</span></code></pre></div>
<p><em>3. analyze</em></p>
<p>First, I want to make a comment about the function findInterval()</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a =<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>)
m =<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>)
<span class="kw">findInterval</span>(m,a)
<span class="co">#&gt; [1] 0 1 3</span></code></pre></div>
<p>Using the above code , we can conclude how the findInterval(par1, par2) works. First, it divides the the real line by the number in par2, and denote the first interval as 0, second interval as 1 and so on. Then compare the elements in par1 to to the element in par2, and allocate an interval to each element in par1. And since it denotes the first interval as 0, so when we implement the inverse transform method, we must add 1 to the result returned by the findInterval function. There is one more detail, the interval findInterval() gives is a left close,right open interval.</p>
<p>And the compare shows that our inverse transformation does generate the discrete random variable the problem gives, and it shows comparative results to the sample() function.</p>
</div>
<div id="assignment-3.7" class="section level3">
<h3>Assignment 3.7</h3>
<p><em>Problem Discription</em></p>
<p>Write a function to generate a random sample of size n from the Beta(a,b) distribution by the acceptance-rejection method. Generate a random sample of size 1000 from the Beta(3,2) distribution. Graph the histogrm of the sample with the theoretical Beta(3,2) density superimposed.</p>
<p><em>Answer</em></p>
<p><em>1. random generator</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n =<span class="st"> </span><span class="dv">1000</span>
k =<span class="st"> </span><span class="dv">0</span>
j =<span class="st"> </span><span class="dv">0</span>
y =<span class="st"> </span><span class="kw">numeric</span>(n)
<span class="cf">while</span>(k<span class="op">&lt;</span>n){
  j =<span class="st"> </span>j<span class="op">+</span><span class="dv">1</span>
  u =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
  x =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
  <span class="cf">if</span>(x<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">&gt;</span>u){
    k =<span class="st"> </span>k<span class="op">+</span><span class="dv">1</span>
    y[k] =<span class="st"> </span>x
  }
}
j
<span class="co">#&gt; [1] 11915</span></code></pre></div>
<p><em>2. Graph</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plot1 =<span class="st"> </span><span class="kw">hist</span>(y, <span class="dt">plot =</span> F)
z =<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1000</span>, <span class="dv">3</span>, <span class="dv">2</span>)
plot2 =<span class="st"> </span><span class="kw">hist</span>(z, <span class="dt">plot =</span> F)
<span class="kw">plot</span>(plot1)
<span class="kw">plot</span>(plot2,<span class="dt">col =</span> <span class="kw">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">4</span>),<span class="dt">add =</span> T)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p><em>3. Analyze</em></p>
<p>First about this code, I think the most tricky part is the plot part. I googled for solution about how to plot two histogram in one part. And the code is the solution I find. I only need to change the color and add the “add = T”, so I can plot two histogram in one figure.</p>
<p>Next about the algorithm. We know that the density function of Beta(a,b) distribution is <span class="math inline">\(\frac{\Gamma(a+b)}{\Gamma(a)*\Gamma(b)}*x^{a-1}*(1-x)^{b-1}\)</span> And so the the coefficient in Beta(3,2) is: <span class="math inline">\(\frac{\Gamma(5)}{\Gamma(3)*\Gamma*(2)}\)</span>. And <span class="math inline">\(\frac{\Gamma(5)}{\Gamma(3)*\Gamma*(2)} = 12\)</span>, so let <span class="math inline">\(f(x)\)</span> be the density of Beta(3,2) and <span class="math inline">\(g(x)\)</span> be the density of our proposl function(in our case <span class="math inline">\(g(x) = 1\)</span>), we have that <span class="math inline">\(\frac{f(x)}{g(x)}\leq12\)</span>. If we let c = 12, we will conjecture that in order to get 1000 random numbers follows Beta(3,2), we will have to generate 12000 random numbers, and the result in part1 verifies my assumption.</p>
<p>In order to get more efficient samplint, we can refine the c, i.e we find the true superium of the Beta(3,2) density function. After easy calculation, we find that <span class="math inline">\(x^{2}*(1-x)\leq \frac{4}{9}\)</span> So <span class="math inline">\(c = 12*\frac{4}{9} = \frac{16}{3}\)</span>, wo in this case, in order to generate 1000 Beta(3,2) random numbers, we will need approximately 5300 random numbers. Now we use one simulation to verify it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n =<span class="st"> </span><span class="dv">1000</span>
k =<span class="st"> </span><span class="dv">0</span>
j =<span class="st"> </span><span class="dv">0</span>
y =<span class="st"> </span><span class="kw">numeric</span>(n)
<span class="cf">while</span>(k<span class="op">&lt;</span>n){
  j =<span class="st"> </span>j<span class="op">+</span><span class="dv">1</span>
  u =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
  x =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
  <span class="cf">if</span>(x<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">&gt;</span><span class="dv">4</span><span class="op">/</span><span class="dv">9</span><span class="op">*</span>u){
    k =<span class="st"> </span>k<span class="op">+</span><span class="dv">1</span>
    y[k] =<span class="st"> </span>x
  }
}
j
<span class="co">#&gt; [1] 5328</span></code></pre></div>
<p>Now we verify we do generate Beta(3,2) random numbers.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">plot1 =<span class="st"> </span><span class="kw">hist</span>(y, <span class="dt">plot =</span> F)
z =<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1000</span>, <span class="dv">3</span>, <span class="dv">2</span>)
plot2 =<span class="st"> </span><span class="kw">hist</span>(z, <span class="dt">plot =</span> F)
<span class="kw">plot</span>(plot1)
<span class="kw">plot</span>(plot2,<span class="dt">col =</span> <span class="kw">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span><span class="op">/</span><span class="dv">4</span>),<span class="dt">add =</span> T)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="assignment-3.12" class="section level3">
<h3>assignment 3.12</h3>
<p><em>Problem Discription</em></p>
<p>Simulate a continous Exponential-Gamma mixture. Suppose that the rate parameter <span class="math inline">\(\Lambda\)</span> has Gamma(r, <span class="math inline">\(\beta\)</span>) distribution and Y has Exp(<span class="math inline">\(\Lambda\)</span>) distribution. That is, (Y|<span class="math inline">\(\Lambda = \lambda\)</span>)~<span class="math inline">\(f_Y(y|\lambda)\)</span> = <span class="math inline">\(\lambda*e^{-\lambda*y}\)</span>. Generate 1000 random observations from this mixture with r = 4, and <span class="math inline">\(\beta = 2\)</span></p>
<p><em>1.generate</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n =<span class="st"> </span><span class="dv">1000</span>
r=<span class="st">  </span><span class="dv">4</span>
beta =<span class="st"> </span><span class="dv">2</span>
lambda =<span class="st"> </span><span class="kw">rgamma</span>(n, r, beta)
x =<span class="st"> </span><span class="kw">rexp</span>(n, lambda)</code></pre></div>
<p><em>2.verify</em> Use exercize3.13, we can verify our simulation through comparison with the Pareto distribution. And we use inverse transform method to generate Pareto distribution</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f =<span class="st"> </span><span class="cf">function</span>(x){
  <span class="dv">2</span><span class="op">*</span>(<span class="dv">1</span><span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span><span class="fl">0.25</span><span class="op">-</span><span class="dv">1</span>)
}
u =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1000</span>)
y =<span class="st"> </span><span class="kw">f</span>(u)
figure1 =<span class="st"> </span><span class="kw">hist</span>(x, <span class="dt">plot =</span> F, <span class="dt">breaks =</span> <span class="dv">40</span>)
figure2 =<span class="st"> </span><span class="kw">hist</span>(y, <span class="dt">plot =</span> F, <span class="dt">breaks =</span> <span class="dv">20</span>)
<span class="kw">plot</span>(figure1)
<span class="kw">plot</span>(figure2, <span class="dt">col =</span> <span class="st">'red'</span>, <span class="dt">add =</span>T)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Through this figure we can conclude that we solve the problem.</p>
</div>
</div>
<div id="this-is-the-work-in-2018-9-30" class="section level1">
<h1>THIS IS THE WORK IN 2018-9-30</h1>
<p>I make it very big here, since it’s the only assigment I forgot to submit, so I use a bit front here.</p>
<div id="problem-5.4" class="section level3">
<h3>Problem 5.4</h3>
<p><em>problem discription</em></p>
<p>Write a function to compute a Monte Carlo estimate of the Beta(3,2) cdf. and use the function to estimate F(x) for <span class="math inline">\(0.1,0.2,\dots,0.9\)</span>. Compare the estimates with the vaues returned by the pbeta function in R.</p>
<p><em>problem solving</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f =<span class="st"> </span><span class="cf">function</span>(x,m){
  u =<span class="st"> </span><span class="kw">runif</span>(m)
  <span class="dv">30</span><span class="op">*</span><span class="kw">mean</span>(x<span class="op">^</span><span class="dv">3</span><span class="op">*</span>u<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x<span class="op">*</span>u)<span class="op">^</span><span class="dv">2</span>)
}
x =<span class="st"> </span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>)<span class="op">/</span><span class="dv">10</span>
m =<span class="st"> </span><span class="dv">10000</span>
result =<span class="st"> </span><span class="kw">c</span>(<span class="ot">NULL</span>)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">9</span>){
  result =<span class="st"> </span><span class="kw">c</span>(result, <span class="kw">f</span>(x[i], m))
}
result
<span class="co">#&gt; [1] 0.008604353 0.058658580 0.162613397 0.313692231 0.501002903 0.678084998</span>
<span class="co">#&gt; [7] 0.837496194 0.943135652 1.000621533</span></code></pre></div>
<p>compare to the pbeta</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">another =<span class="st"> </span><span class="kw">pbeta</span>(x, <span class="dv">3</span>, <span class="dv">3</span>)
result<span class="op">/</span>another
<span class="co">#&gt; [1] 1.0051814 1.0127517 0.9971388 0.9881938 1.0020058 0.9934438 1.0006885</span>
<span class="co">#&gt; [8] 1.0011206 1.0092608</span></code></pre></div>
<p><em>analysis</em></p>
<p>Through last result, we can conclude that our monte carlo integration do make a good work. First I will derive the formula in my code. denode <span class="math inline">\(y = \frac{t}{x}\)</span> <span class="math inline">\(\int_0^xt^{\alpha-1}*(1-t)^{\beta-1}dt = \int_0^1 x^\alpha*y^{\alpha-1}*(1-xy)^{\beta-1}dy\)</span> And another way to estimate F(x) is through the following code. Assume that we can generate random number which follows beta distribution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z =<span class="st"> </span><span class="kw">rbeta</span>(m, <span class="dv">3</span>,<span class="dv">3</span>)
<span class="kw">dim</span>(x) =<span class="st"> </span><span class="kw">length</span>(x)
p =<span class="st"> </span><span class="kw">apply</span>(x, <span class="dt">MARGIN =</span> <span class="dv">1</span>, <span class="dt">FUN =</span> <span class="cf">function</span>(x,z){<span class="kw">mean</span>(z<span class="op">&lt;</span>x)}, <span class="dt">z =</span> z)
result<span class="op">/</span>p
<span class="co">#&gt; [1] 0.8779952 0.9430640 0.9679369 0.9672903 0.9860321 0.9899051 1.0052769</span>
<span class="co">#&gt; [8] 1.0015245 1.0081829</span></code></pre></div>
</div>
<div id="problem-5.9" class="section level3">
<h3>problem 5.9</h3>
<p><em>problem discription</em></p>
<p>The Rayleigh density is <span class="math inline">\(f(x) = \frac{x}{\sigma^2}*e^{-\frac{x^2}{2\sigma^2}}, x\geq0, \sigma&gt;0\)</span>. Implement a function to generate samples from <span class="math inline">\(Rayleigh(\sigma)\)</span> distribution, using antithetic variables. What is the percent reduction in variance of <span class="math inline">\(\frac{X+X'}{2}\)</span> compared with <span class="math inline">\(\frac{X_1+X_2}{2}\)</span> for independent <span class="math inline">\(X_1, X_2\)</span> ? <em>problem solving</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f =<span class="st"> </span><span class="cf">function</span>(m, sigma){
  u =<span class="st"> </span><span class="kw">runif</span>(m<span class="op">/</span><span class="dv">2</span>)
  x =<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="dv">1</span><span class="op">-</span>u))
  x_ =<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(u))
  <span class="kw">c</span>(x, x_)
}
m =<span class="st"> </span><span class="dv">10000</span>
sigma =<span class="st"> </span><span class="dv">2</span>
result =<span class="st"> </span><span class="kw">f</span>(m, sigma);
X =<span class="st"> </span>result[<span class="dv">1</span><span class="op">:</span>(m<span class="op">/</span><span class="dv">2</span>)]
X_ =<span class="st"> </span>result[(m<span class="op">/</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>m]
var1 =<span class="st"> </span><span class="kw">sd</span>((X<span class="op">+</span>X_)<span class="op">/</span><span class="dv">2</span>)
X1 =<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">runif</span>(m<span class="op">/</span><span class="dv">2</span>)))
X2 =<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="dv">1</span><span class="op">-</span><span class="kw">runif</span>(m<span class="op">/</span><span class="dv">2</span>)))
var2 =<span class="st"> </span><span class="kw">sd</span>((X1<span class="op">+</span>X2)<span class="op">/</span><span class="dv">2</span>)
var1<span class="op">/</span>var2
<span class="co">#&gt; [1] 0.222716</span></code></pre></div>
<p><em>analysis</em></p>
<p>Our first variance is approximately 1/5 of the second variance, which shows the power of the antithetic variables. And the following we will show that why this may happen. <span class="math inline">\(cov(X, X') = E(XX')-E(X)E(X') = 2*\sigma^2E(ln(1-u)*ln(u))-2*\sigma^2*E(lnu)^2, u \sim U(0,1)\)</span> And bellow I will compute the two expectation in the formula.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="dv">10000</span>
u =<span class="st"> </span><span class="kw">runif</span>(m)
cov =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>((<span class="kw">mean</span>(<span class="kw">sqrt</span>(<span class="kw">log</span>(<span class="dv">1</span><span class="op">-</span>u)<span class="op">*</span><span class="kw">log</span>(u)))<span class="op">-</span><span class="kw">mean</span>(<span class="kw">sqrt</span>(<span class="op">-</span><span class="kw">log</span>(u)))<span class="op">^</span><span class="dv">2</span>))
<span class="kw">sqrt</span>((<span class="dv">4</span><span class="op">-</span>pi<span class="op">+</span><span class="dv">2</span><span class="op">*</span>cov)<span class="op">/</span>((<span class="dv">4</span><span class="op">-</span>pi)<span class="op">*</span><span class="dv">2</span>))
<span class="co">#&gt; [1] 0.2029114</span></code></pre></div>
<p>this is the theoretical result , compare to our empirical result, they are very close. So we can conclude our algorithm is right.</p>
</div>
<div id="problem-5.13" class="section level2">
<h2>problem 5.13</h2>
<p><em>problem discription</em></p>
<p>Find two importance functions <span class="math inline">\(f_1 and f_2\)</span> that are supported on <span class="math inline">\((1, \infty)\)</span> and are ‘close’ to <span class="math inline">\(g(x) = \frac{x^2}{\sqrt{2\pi}}*e^{\frac{-x^2}{2}}, x&gt;1\)</span>. Which of your two importance functions produce the smaller variance in estimating <span class="math inline">\(\int_1^\infty \frac{x^2}{\sqrt{2\pi}}*e^{\frac{-x^2}{2}}dx\)</span> by importance sampling.</p>
<p><em>problem solving</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="dv">100000</span>
g =<span class="st"> </span><span class="cf">function</span>(x){
  x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>(x<span class="op">&gt;</span><span class="dv">1</span>)
}
u =<span class="st"> </span><span class="kw">rnorm</span>(m)
simu1 =<span class="st"> </span><span class="kw">g</span>(u)<span class="op">/</span><span class="kw">dnorm</span>(u)
u =<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="kw">runif</span>(m)))
simu2 =<span class="st"> </span><span class="kw">g</span>(u)<span class="op">/</span>(u<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>u<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>))
<span class="kw">plot</span>(g, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">10</span>))
<span class="kw">plot</span>(<span class="cf">function</span>(x){<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)}, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">10</span>),<span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">'red'</span>)
<span class="kw">plot</span>(<span class="cf">function</span>(x){x<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)}, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">10</span>),<span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">'yellow'</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sd</span>(simu1)
<span class="co">#&gt; [1] 1.145918</span>
<span class="kw">sd</span>(simu2)
<span class="co">#&gt; [1] 0.3582711</span></code></pre></div>
<p><em>analysis</em></p>
<p>I use two f.The first is <span class="math inline">\(f(x) = \frac{1}{\sqrt{2\pi}}*e^{-\frac{x^2}{2}}\)</span> and the second is <span class="math inline">\(f(x) = x*exp(-\frac{x^2}{2})\)</span>. But just use the figure, I cannot find which one is better.Luckily, through the analysis of variance, we may choose the second one. And by intuition, this is also true since x is more close to constant compare to <span class="math inline">\(x^2\)</span>.</p>
<div id="problem-5.14" class="section level3">
<h3>problem 5.14</h3>
<p><em>problem discription</em></p>
<p>Obtain a Monte Carlo extimate of <span class="math inline">\(\int_1^\infty\frac{x^2}{\sqrt{2\pi}}*e^{\frac{-x^2}{2}}dx\)</span> by importance sampling.</p>
<p><em>problem solving</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="dv">10000</span>
g =<span class="st"> </span><span class="cf">function</span>(x){
  x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>(x<span class="op">&gt;</span><span class="dv">1</span>)
}
u =<span class="st"> </span><span class="kw">rnorm</span>(m)
simu1 =<span class="st"> </span><span class="kw">g</span>(u)<span class="op">/</span><span class="kw">dnorm</span>(u)
u =<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="kw">runif</span>(m)))
simu2 =<span class="st"> </span><span class="kw">g</span>(u)<span class="op">/</span>(u<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>u<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>))
<span class="kw">mean</span>(simu1)
<span class="co">#&gt; [1] 0.3843129</span>
<span class="kw">mean</span>(simu2)
<span class="co">#&gt; [1] 0.4010422</span></code></pre></div>
<p><em>analysis</em></p>
<p>we can see that the two functions give similar result, but there is still some difference. We will demonstrate the difference in the following.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="dv">10000</span>
g =<span class="st"> </span><span class="cf">function</span>(x){
  x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>(x<span class="op">&gt;</span><span class="dv">1</span>)
}
n =<span class="st"> </span><span class="dv">20</span>
theta =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span>(<span class="dv">2</span><span class="op">*</span>n), <span class="dt">nrow =</span> <span class="dv">2</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){
  u =<span class="st"> </span><span class="kw">rnorm</span>(m)
  simu1 =<span class="st"> </span><span class="kw">g</span>(u)<span class="op">/</span><span class="kw">dnorm</span>(u)
  theta[<span class="dv">1</span>,i] =<span class="st"> </span><span class="kw">mean</span>(simu1)
  u =<span class="st"> </span><span class="kw">sqrt</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span><span class="kw">log</span>(<span class="kw">runif</span>(m)))
  simu2 =<span class="st"> </span><span class="kw">g</span>(u)<span class="op">/</span>(u<span class="op">*</span><span class="kw">exp</span>(<span class="op">-</span>u<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>))
  theta[<span class="dv">2</span>,i] =<span class="st"> </span><span class="kw">mean</span>(simu2)
}
<span class="kw">sd</span>(theta[<span class="dv">1</span>,])
<span class="co">#&gt; [1] 0.01011296</span>
<span class="kw">sd</span>(theta[<span class="dv">2</span>,])
<span class="co">#&gt; [1] 0.003453743</span></code></pre></div>
<p>through print out the true value, we can also see that the first importance function suffer from more fluctuation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">theta[<span class="dv">1</span>,]
<span class="co">#&gt;  [1] 0.3835174 0.4022907 0.3984356 0.3898144 0.4074574 0.4055642 0.4020945</span>
<span class="co">#&gt;  [8] 0.4048122 0.4003418 0.3768312 0.3987975 0.3908770 0.3960074 0.4131467</span>
<span class="co">#&gt; [15] 0.4060776 0.4173646 0.3990151 0.4035929 0.4127401 0.4119314</span>
theta[<span class="dv">2</span>,]
<span class="co">#&gt;  [1] 0.3989425 0.4071709 0.3962555 0.3931950 0.3981435 0.4044970 0.4030296</span>
<span class="co">#&gt;  [8] 0.4028364 0.4004089 0.4008213 0.3972603 0.3973064 0.3985976 0.4038852</span>
<span class="co">#&gt; [15] 0.3991232 0.3976990 0.3962370 0.4003959 0.4039070 0.4021781</span></code></pre></div>
</div>
</div>
<div id="this-is-the-work-in-2018-10-12" class="section level2">
<h2>This is the work in 2018-10-12</h2>
<div id="section" class="section level3">
<h3>6.9</h3>
<p><em>problem discription</em></p>
<p>Let X be a non-negative random variable with ?? = E[X] &lt; ??. For a random sample <span class="math inline">\(x_1,\ldots,x_n\)</span> from the distribution of X, the Gini ratio is de???ned by <span class="math inline">\(G = \frac{1}{2n^2\mu}\sum_{j=1}^n\sum_{i=1}^{n}|x_i-x_j\)</span> The Gini ratio is applied in economics to measure inequality in income distribution. Note that G can be written in terms of the order statistics <span class="math inline">\(x_{(i)}\)</span> as <span class="math inline">\(G=\frac{1}{n^2\mu}\sum_{i=1}^n(2i-n-1)x_{x(i)}\)</span> If the mean is unknown,let <span class="math inline">\(\hat G\)</span>be the statistic G with <span class="math inline">\(\mu\)</span> replaced by <span class="math inline">\(\bar x\)</span>. Estimate by simulation the mean, median and deciles of <span class="math inline">\(\hat G\)</span> if X is standard lognormal. Repeat the procedure for the uniform distribution and Bernoulli(0.1). Also construct density histograms of the replicates in each case.</p>
<p><em>prolem solving</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Gini =<span class="st"> </span><span class="cf">function</span>(x){
  x =<span class="st"> </span><span class="kw">sort</span>(x)
  x.bar =<span class="st"> </span><span class="kw">mean</span>(x)
  n =<span class="st"> </span><span class="kw">length</span>(x)
  a =<span class="st"> </span><span class="dv">1</span><span class="op">:</span>n
  a =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>a<span class="op">-</span>(n<span class="op">+</span><span class="dv">1</span>)
  G =<span class="st"> </span><span class="dv">1</span><span class="op">/</span>(n<span class="op">^</span><span class="dv">2</span><span class="op">*</span>x.bar)<span class="op">*</span><span class="kw">sum</span>(a<span class="op">*</span>x)
  G
}
m =<span class="st"> </span><span class="fl">1e3</span>
n =<span class="st"> </span><span class="fl">1e2</span>
lognormal.simu =<span class="st"> </span>uniform.simu =<span class="st"> </span>bernoulli.simu =<span class="st"> </span><span class="kw">numeric</span>(m)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x =<span class="st"> </span><span class="kw">rlnorm</span>(n)
  y =<span class="st"> </span><span class="kw">runif</span>(n)
  z =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>, n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
  lognormal.simu[i] =<span class="st"> </span><span class="kw">Gini</span>(x)
  uniform.simu[i] =<span class="st"> </span><span class="kw">Gini</span>(y)
  bernoulli.simu[i] =<span class="st"> </span><span class="kw">Gini</span>(z)
}
<span class="kw">summary</span>(lognormal.simu)
<span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span>
<span class="co">#&gt;  0.4088  0.4809  0.5080  0.5097  0.5346  0.7189</span>
lognormal.simu =<span class="st"> </span><span class="kw">sort</span>(lognormal.simu)
lognormal.simu[((<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>)<span class="op">/</span><span class="dv">10</span>)<span class="op">*</span>m]
<span class="co">#&gt; [1] 0.4600873 0.4752969 0.4878439 0.4974255 0.5078932 0.5182790 0.5288466</span>
<span class="co">#&gt; [8] 0.5406281 0.5609486</span>
<span class="kw">plot</span>(<span class="kw">density</span>(lognormal.simu))</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAz1BMVEUAAAAAADoAAGYAOjoAOmYAOpAAZpAAZrY6AAA6ADo6AGY6OgA6Ojo6OmY6OpA6ZpA6ZrY6kLY6kNtmAABmADpmOgBmOjpmZgBmZmZmkJBmkLZmkNtmtrZmtttmtv+QOgCQZgCQZjqQkDqQkGaQkLaQtpCQttuQtv+Q29uQ2/+2ZgC2Zjq2ZpC2kDq2kGa225C227a229u22/+2/7a2/9u2//++vr7bkDrbkGbbtmbbtpDb27bb29vb/7bb////tmb/25D/27b//7b//9v///8a20xqAAAACXBIWXMAAA7DAAAOwwHHb6hkAAANJklEQVR4nO2dfWPbthHGIcWe1Hh9ieR0r5HbdWkrpt06dx7bdDFlWd//MxXAgSBAEjgSBChSuecPR6FOh8OPhxdSEMhOJK/YuQOYuggQIgKEiAAhIkCICBAiAoSIACEiQIgIECIChIgAISJAiAgQIgKEiAAhIkCICBAiAoSIACEiQIgIECIChIgAISJAiAgQIgKEiAAhIkCICBAiAoSIACGqAGVs+YDbP9+x60f+zw9u27qj53drxr7o4O64Xew7lh9frY75wTBAT689tnVHBePadHCXd6j75AF1sK2/mTN3YkBY8An+2oGx8YEEcjkWgEQbuPpWRfmOscUXwpLX63v+nytZuV9u+OHP75WfTOTE4oatxFs8QXZlIW2OwHh/ev+a//up8AYGxy3nUblbPhTC6rAWb/LDCjL/P0hBLuvx/kvGXvz1EUoVUUqnVsyGDT/+9jVb/rRlq/c3bPHm9MtaGemoTEBmbRn8ZRCjiFro6kE4rSLLtYFRo39AJaqEaXekABWVNwegXB7ORXPMNXQHIBWQ7L/u1OmSgAxjwwZeXn/YqvdvVJSnKioDkFVbJo1Wj+I0LEVtlvciqI00u7qHeHldVo+nX1lZI6giN9vJeq4UeKcjKP8Pj+pAHRAc4C9XQGDxdq2DbQd0kAYyNlVqxhSgMmbLhv+9vj/9X5y1jagHewNvGFFVgOzaMiPe5YMMWviDwnaymJX4c/Ufs6kaNTJamNORqtxv/+JnbuUCVJKWSJy9ltlpwT9GqWbMlo3KSG7EPwx/4VxVUVWA7Nqy8sxJT+b5gnrJsCGLZXM2A8whvvJk+x09fw0HnIB0xJl70FPll5URnsvXWXUuypi1TXmO4BzAXyiuiqoCZNeW6TOXyX6yFRAfh+HodxYg0cZUqpxOJ78jUdTVP3/bVoCMxLYBFWsjgVqbWFmSyF6zVDNm08YJyIjK6IOs2rKTeQqgWwGZgPiHvrmRHV5tXF4ZY7jXEVT/2AGQPIF6QGkFFC2DjKisYd6obaMPWln1Mvvg56+4hdUH5GLwqNz6HBVl71D22uJIK6BcDjJlWrZ30u4+qIrZ7oPaARlR1edBZW2ZPQxkYpLwtIX+XxfGLV6J+a4+eapAGf1Gh+1zJMeUpzvZB8kBRLwuw5IWiqkw5MOxq5fGRrEKkD2KOTOojKpKTbu27KSmctb0BeY+VWHvatOFopomyNOk8Hsc6TnSysiKjenuv7KPF6O8zLeVD5B7HmRkvTUPcvdBZicN3q3aypn0j2v24g2k5NPXPHoxibQL+1W0yU/LmTRMXu9PuiLlNafHkRgvrr6FyeCB94Kf/1SNYuAuV6w2cM52PkAwS/4bHOKf/uy+3gdZNt5RDKIyOzeztsNudxSueoQ5wy/m3crsLiSaBgHi7bT7BS4qfrpCaGfyXgpMDhNoACDZzeDX392VB9WxnHINST+PhgFavIoXiXAYlI9PX67VxXcK0S1XRAQIEQFCRIAQESBEBAgRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQESBEBAgRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCFBkQm43OBSiuu3QiQIhGBtQ/c8+t+WXQyGznBkjk3qiIZgYI2IxJaG6Ahn18QInxDFO606kzXg7NDFD1aixCswJkfmgsQrMFNFY3NCdA9mdGSqH5AhophWYEqP6RcVJoxoDGSaE5AxqF0HwAtbQoAoR8YoxeaNaAxkih2QBq/cB8AWWMreQvhV2/nfzIAeXyN/3yh8OOn2LGATQCoSSAnu/E7/hhbx7HT4z71sxhP1NAxy1vWYX8XWlh/7o0+Ka9yz45oZln0EwBVX2QRDXYncd8poCij2Ju89SEZjIPIkDB1tMDZG6JNEK5mPX0AMF+O0O34ogGKDWhwCY2mFGvanmNpwkIEA3Y8ubCARVyAH++C9+q6JIBie2AgEwRnkJ9qoXYpiUUMorF2KHokgHdAp8B6dOnXNx2qoByAtRmmFU3LEYb5jHbpITCM2ikcjuYTgzQyOUSoOGmUwJ03G6O5X7vY3XSuGlKQtPPoA6WFwQo4Kb9/ACJ77pyNnDL2EsGlF0/HtarUzbotlnczE1IKORabMev5ndjXWrME1Am9qwmQA7DbHXciicyUBNzGIrdj/fPd8Pu3Hctt6NdOkJTnwcRoDh2kwJUPkJhlE56joCyGPv3RwaUjlDIMB9j//7YmTEpQDGekHHBgIYO8L3KjXrJFqSAU1TEeMjKBQMa84ZZ1NtqYZr2PIgARSw0EaEQQPLpkVmHwf6wdvZWlwyoWOxzcTXvJqS7KXdPFf8ifTKAxMpesczXdz+ogK9dh2ZQvzqnIRQ2URSAvHcUxR2jNkD9btrPE1CZQZn/rn0mH+g4KIN61jjNz+uC+6Acmy7mbDMuoDQpFDiKdXnO22H94iMF1FW+ZxGmAJSE0IQniv1LnAYgmOQMfRTn5QLKoNnkA9faJwGUglBfQEXZOXtGqDjlhlT2/ICMu2Wpv5sPqmx8Qj0BGVdgqb96nisg3bASL14IrGp0QgQolsOZAIpOiADF8lcCQm+FxSk3uJ6xr+mneqkRXtzHAWhAaZFT6PIARY70AgHFDXWagIYVFrWRjQyo4037gYXNGFBHdwTI725wWRGDvVBA8aK9TEARo50ioBhFRQuXAMVyNB6gSBOKKF4uGVCkgKcHaPSaRXIzHqD0RSTxMhagiAN0FFcXDCiOq6kBOs+VeAwf4wCKfTtwxDn5KICir6Ib7nBSgBKsMhz8NMVEgNBfJba4S/VkyGF+0wDSq4cK1zKihruUD84c8lTOJICMXaQ7brid/rmioY/gTQLI/QW1ju5/s1EKQP0zaLpK1QepFOreB01ViUaxcpGDczHsxw5obHfpdDZAs9GZAAU7P7tpQhdRnJ/dNKGLKM7PbprQRRTnZzdN6CKK87ObJnQRxfnZTRO6iOL87KYJXURxfnbThC6iOD+7aUIXly0ChIgAISJAiAgQIgKEiAAhIkCICBAiAoSIACEiQIgIEKIUgIraRlaebdFMU/hW0rl1iOX1sPZYmqaF+pYneMuWBIDETjKFQahwfxFrmR4+8W0PZpkW3KP7+Q31ADymuOIDgiUO1SYycoPPLqbeLQ0sU/iPaxuWegDDNmyJDwh2IKpiyq+/cgGyTXPfabZM/blWD4AfGLBrVAJAMnqdDvy/zj7INs3+yNxPWLRMi+XP246m0vGQzSTiA4LWX/YBIt+dgCxT2OXTtdmuZZqLRZLOLdTtAIbu1p8akHdzz3pVTu6OyAa02Hc1rfvvrcRNTP6nYxODQ4491CxT6F86mZ68s4wOStxJ595pSKM7dfe/lilUvpPp4OdhpB/mPafQMoV6udqNZQqrSTuZjrCvX2815mnuHLdMZZWcO6JbpqJnM5aUegMY1gUludTIYaavhxlPJ2CZZt5LAsu08MwIaqbDtvWji1VMBAgRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQESBEBAgRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQESBEBAgRAULUE9DzHXzT7fq6/fAS1qeU63CbLwxlcmWMZ22Bve6g2iFMrk7YmVuGNT5p+m0GkTeOlOuKG2uRewOCDzsAHbeSn15e0XxhCpzkbkKuhRn8uIDjBmSvGW4EoR9YXb1VrituLDrqDeiF9NAOqIAdFvUCneYLS+DEs8ApFFDLmmEzCCgxv36svSXWgTQWHfUGtJKrdVsBFWwj/eslXs0Xln0JSLynlr4ct3/fwhoY0Qq+WXwvVrAU4kB2/WFbHX/LWwQ/8Jd164IZe81wIwi9iLF6S+dNYy1yf0CyQgqQaLlWNwKAykWCzRctgAD4Ctraccv/iBdi6W7B5APMORN5jqFgdRwySBnXI2kuk7SCUIDYrjqi1xU31iL3B+RduCqD0meo+cIGBOsXRfO/3cOpltnPX8C5zeCT2Z+vH3ldBBN9HABt2lfYWcU1g1CJw3b6iF5X3FyLHADIt/S5HyDppFBjRiFai8wS/qcoO3v++nj79iU/xw/iPfO4Nu4LSHXSJiB7XbGZ6gGAxOe9gPo1MdlqeM+y/Pe6qnOuR8Nsc/jsw+1e9q27U94JENLEZO4uf77d6yO1dcVmVoYA4kH7+6BenbR+/7BuySDeoH9cnbJXd/CeM4PsPsjfSSsKL41u215XbI71QYAOn9z4MqjfMC/+gZZpNDEVumgKL/+0OeViclH1QTmSQcgwDzKHeb2uuLkWOQgQT1EfoH4TRcEFkoePHrrOgo0YrWCokj85k++Vx0UH7QSETBTljNAOS68rbqxFDgMEnb0TUDWVb74wAVWtQr6tBidFQs539tBFyR80HY150F6cow9OQLWFwPUgxPVE85oDRvf6WmS6WEVEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQESBEBAgRAUJEgBARIEQECBEBQkSAEBEgRAQIEQFCRIAQESBEBAjR74LUHaL9zHjSAAAAAElFTkSuQmCC" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">density</span>(uniform.simu))</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">density</span>(bernoulli.simu))</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p><em>analysis</em></p>
<p>It’s easy to use summary function to give sample mean and some quantile statistics for samples. And use a function to generate Gini ratio will save our time to compute the Gini ratio. And to verify our computation. We can easily derive that if <span class="math inline">\(X ~ uniform(0,1)\)</span> then, the Gini ratio is <span class="math inline">\(\frac{1}{3}\)</span>. And through the figure and the summary given below , we can see the density are concentrated on <span class="math inline">\(\frac{1}{3}\)</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(uniform.simu)
<span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span>
<span class="co">#&gt;  0.2577  0.3166  0.3313  0.3314  0.3470  0.4004</span>
<span class="kw">plot</span>(<span class="kw">density</span>(uniform.simu))</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="section-1" class="section level3">
<h3>6.10</h3>
<p><em>problem discription</em></p>
<p>Construct an approximate 95% confidence interval for the Gini ratio <span class="math inline">\(\gamma = E[G]\)</span>.If X is lognormal with unknown parameters. Assess the coverage rate of the estimation procedure with a Monte Carlo experiment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(boot)
sigma =<span class="st"> </span><span class="dv">1</span>
m =<span class="st"> </span><span class="dv">100</span>
n =<span class="st"> </span><span class="dv">100</span>
boot.Gini =<span class="st"> </span><span class="cf">function</span>(x,i) <span class="kw">Gini</span>(x[i])
ci.norm&lt;-ci.basic&lt;-ci.perc&lt;-ci.bca&lt;-<span class="kw">matrix</span>(<span class="ot">NA</span>,m,<span class="dv">2</span>) 
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x =<span class="st"> </span><span class="kw">rlnorm</span>(n,<span class="dv">0</span>,sigma)
  de =<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data =</span> x, <span class="dt">statistic =</span> boot.Gini, <span class="dt">R =</span> <span class="dv">100</span>)
  ci =<span class="st"> </span><span class="kw">boot.ci</span>(de,<span class="dt">type=</span><span class="kw">c</span>(<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;basic&quot;</span>,<span class="st">&quot;perc&quot;</span>))
  ci.norm[i,]&lt;-ci<span class="op">$</span>norm[<span class="dv">2</span><span class="op">:</span><span class="dv">3</span>]
  ci.basic[i,]&lt;-ci<span class="op">$</span>basic[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]            
  ci.perc[i,]&lt;-ci<span class="op">$</span>percent[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
}
G =<span class="st"> </span>(<span class="kw">pnorm</span>(<span class="fl">0.5</span>, <span class="dv">0</span>, <span class="kw">sqrt</span>(<span class="fl">0.5</span>))<span class="op">-</span><span class="fl">0.5</span>)<span class="op">*</span><span class="dv">2</span>
<span class="kw">cat</span>(<span class="st">'norm ='</span>,<span class="kw">mean</span>(ci.norm[,<span class="dv">1</span>]<span class="op">&lt;=</span>G <span class="op">&amp;</span><span class="st"> </span>ci.norm[,<span class="dv">2</span>]<span class="op">&gt;=</span>G), 
    <span class="st">'basic ='</span>,<span class="kw">mean</span>(ci.basic[,<span class="dv">1</span>]<span class="op">&lt;=</span>G <span class="op">&amp;</span><span class="st"> </span>ci.basic[,<span class="dv">2</span>]<span class="op">&gt;=</span>G), 
    <span class="st">'perc ='</span>,<span class="kw">mean</span>(ci.perc[,<span class="dv">1</span>]<span class="op">&lt;=</span>G <span class="op">&amp;</span><span class="st"> </span>ci.perc[,<span class="dv">2</span>]<span class="op">&gt;=</span>G))
<span class="co">#&gt; norm = 0.85 basic = 0.85 perc = 0.83</span></code></pre></div>
<p><em>analysis</em></p>
<p>Since we do not know the distribution of Gini ratio, so we cannot give a parametric confidence interval for Gini ratio. So what I do here, is using the boot function to use bootstrap method to give confidence intervals and the above shows that the confidence interval is too liberal.But if we enlarge n and R, the result will be better, I will illustrate in the following.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sigma =<span class="st"> </span><span class="dv">1</span>
m =<span class="st"> </span><span class="dv">100</span>
n =<span class="st"> </span><span class="dv">500</span>
boot.Gini =<span class="st"> </span><span class="cf">function</span>(x,i) <span class="kw">Gini</span>(x[i])
ci.norm&lt;-ci.basic&lt;-ci.perc&lt;-ci.bca&lt;-<span class="kw">matrix</span>(<span class="ot">NA</span>,m,<span class="dv">2</span>) 
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x =<span class="st"> </span><span class="kw">rlnorm</span>(n,<span class="dv">0</span>,sigma)
  de =<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data =</span> x, <span class="dt">statistic =</span> boot.Gini, <span class="dt">R =</span> <span class="dv">200</span>)
  ci =<span class="st"> </span><span class="kw">boot.ci</span>(de,<span class="dt">type=</span><span class="kw">c</span>(<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;basic&quot;</span>,<span class="st">&quot;perc&quot;</span>))
  ci.norm[i,]&lt;-ci<span class="op">$</span>norm[<span class="dv">2</span><span class="op">:</span><span class="dv">3</span>]
  ci.basic[i,]&lt;-ci<span class="op">$</span>basic[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]            
  ci.perc[i,]&lt;-ci<span class="op">$</span>percent[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
}
G =<span class="st"> </span>(<span class="kw">pnorm</span>(<span class="fl">0.5</span>, <span class="dv">0</span>, <span class="kw">sqrt</span>(<span class="fl">0.5</span>))<span class="op">-</span><span class="fl">0.5</span>)<span class="op">*</span><span class="dv">2</span>
<span class="kw">cat</span>(<span class="st">'norm ='</span>,<span class="kw">mean</span>(ci.norm[,<span class="dv">1</span>]<span class="op">&lt;=</span>G <span class="op">&amp;</span><span class="st"> </span>ci.norm[,<span class="dv">2</span>]<span class="op">&gt;=</span>G), 
    <span class="st">'basic ='</span>,<span class="kw">mean</span>(ci.basic[,<span class="dv">1</span>]<span class="op">&lt;=</span>G <span class="op">&amp;</span><span class="st"> </span>ci.basic[,<span class="dv">2</span>]<span class="op">&gt;=</span>G), 
    <span class="st">'perc ='</span>,<span class="kw">mean</span>(ci.perc[,<span class="dv">1</span>]<span class="op">&lt;=</span>G <span class="op">&amp;</span><span class="st"> </span>ci.perc[,<span class="dv">2</span>]<span class="op">&gt;=</span>G))
<span class="co">#&gt; norm = 0.89 basic = 0.89 perc = 0.88</span></code></pre></div>
<p>Following I will use another way to build confidence interval.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mu =<span class="st"> </span><span class="dv">0</span>
sigma =<span class="st"> </span><span class="dv">1</span>
M =<span class="st"> </span><span class="dv">1000</span>
n =<span class="st"> </span><span class="dv">50</span>
Sig1 =<span class="st"> </span>Sig2 =<span class="st"> </span>Mu_hat =<span class="st"> </span>Sigma_hat =<span class="st"> </span>result =<span class="st"> </span>G1 =<span class="st"> </span>G2 =<span class="st"> </span><span class="kw">numeric</span>(M)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M) {
  x =<span class="st"> </span><span class="kw">rlnorm</span>(n, mu, sigma)
  y =<span class="st"> </span><span class="kw">log</span>(x)
  S =<span class="st"> </span><span class="kw">sd</span>(y)
  Sig1[i] =<span class="st"> </span><span class="kw">sqrt</span>((n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>S<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span><span class="kw">qchisq</span>(<span class="fl">0.025</span>, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>))
  Sig2[i] =<span class="st"> </span><span class="kw">sqrt</span>((n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>S<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span><span class="kw">qchisq</span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="fl">0.025</span>, n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>))
}

<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>M){
  G1[i] =<span class="st"> </span>(<span class="kw">pnorm</span>(Sig1[i]<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="kw">sqrt</span>(<span class="fl">0.5</span>))<span class="op">-</span><span class="fl">0.5</span>)<span class="op">*</span><span class="dv">2</span>
  G2[i] =<span class="st"> </span>(<span class="kw">pnorm</span>(Sig2[i]<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="kw">sqrt</span>(<span class="fl">0.5</span>))<span class="op">-</span><span class="fl">0.5</span>)<span class="op">*</span><span class="dv">2</span>
}
G =<span class="st"> </span>(<span class="kw">pnorm</span>(<span class="fl">0.5</span>, <span class="dv">0</span>, <span class="kw">sqrt</span>(<span class="fl">0.5</span>))<span class="op">-</span><span class="fl">0.5</span>)<span class="op">*</span><span class="dv">2</span>
<span class="kw">mean</span>(G1<span class="op">&lt;=</span>G <span class="op">&amp;</span><span class="st"> </span>G2<span class="op">&gt;=</span>G)
<span class="co">#&gt; [1] 0.939</span></code></pre></div>
</div>
<div id="b" class="section level3">
<h3>6.B</h3>
<p><em>problem discription</em></p>
<p>Tests for association based on Pearson product moment correlation ??, Spearman??s rank correlation coe???cient <span class="math inline">\(\rho_s\)</span>, or Kendall??s coe???cient <span class="math inline">\(\tau\)</span>, are implemented in cor.test. Show (empirically) that the nonparametric tests based on <span class="math inline">\(\rho_s\)</span> or <span class="math inline">\(\tau\)</span> are less powerful than the correlation test when the sampled distribution is bivariate normal. Find an example of an alternative (a bivariate distribution (X,Y) such that X and Y are dependent) such that at least one of the nonparametric tests have better empirical power than the correlation test against this alternative.</p>
<p><em>problem solving</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)
m =<span class="st"> </span><span class="fl">1e3</span>
Sigma =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="dv">1</span>),<span class="dv">2</span>,<span class="dv">2</span>)
result =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span>(<span class="dv">3</span><span class="op">*</span>m), <span class="dt">nrow =</span> <span class="dv">3</span>)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  mnorm =<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dt">n =</span> <span class="dv">100</span>, <span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">2</span>), Sigma)
  x =<span class="st"> </span>mnorm[,<span class="dv">1</span>]
  y =<span class="st"> </span>mnorm[,<span class="dv">2</span>]
  result[<span class="dv">1</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x,y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'pearson'</span>)<span class="op">$</span>p.value
  result[<span class="dv">2</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x, y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'kendal'</span>)<span class="op">$</span>p.value
  result[<span class="dv">3</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x, y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'spearman'</span>)<span class="op">$</span>p.value
}
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>){
  <span class="kw">print</span>(<span class="kw">mean</span>(result[i,]<span class="op">&lt;=</span><span class="fl">0.05</span>))
}
<span class="co">#&gt; [1] 0.288</span>
<span class="co">#&gt; [1] 0.266</span>
<span class="co">#&gt; [1] 0.268</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x =<span class="st"> </span><span class="kw">rchisq</span>(<span class="dv">100</span>, <span class="dt">df =</span> <span class="dv">3</span>)
  y =<span class="st"> </span><span class="dv">1</span><span class="op">/</span><span class="dv">10</span><span class="op">*</span>x <span class="op">+</span><span class="dv">9</span><span class="op">/</span><span class="dv">10</span><span class="op">*</span><span class="kw">rchisq</span>(<span class="dv">100</span>, <span class="dt">df =</span> <span class="dv">3</span>)
  result[<span class="dv">1</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x,y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'pearson'</span>)<span class="op">$</span>p.value
  result[<span class="dv">2</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x, y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'kendal'</span>)<span class="op">$</span>p.value
  result[<span class="dv">3</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x, y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'spearman'</span>)<span class="op">$</span>p.value
}
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>){
  <span class="kw">print</span>(<span class="kw">mean</span>(result[i,]<span class="op">&lt;=</span><span class="fl">0.05</span>))
}
<span class="co">#&gt; [1] 0.198</span>
<span class="co">#&gt; [1] 0.251</span>
<span class="co">#&gt; [1] 0.249</span></code></pre></div>
<p><em>analysis</em> It is our common sense that if the samples do follow some parametric distribution, the related test wiill give best test. So if (X,Y) come from two dimensional normal distribution, the pearson test will give the best power. However, when the distribution are far away from normal distribution, the nonparametric method will come into stage. Since the advantages of the nonparametric method is its universality, it does not have any assumption about how the samples are distributed. So inorder to let the power of the latter two method, I can just make the distribution far away from distribution and the nonparametric method will of course be better than the parametric method. To be more illustrated, I will use more example to show when the data is fram Normal distribution , the power of the Pearson test is the strongest.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="fl">1e3</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>){
  Sigma =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>,i<span class="op">/</span><span class="dv">10</span>,i<span class="op">/</span><span class="dv">10</span>,<span class="dv">1</span>),<span class="dv">2</span>,<span class="dv">2</span>)
  result =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span>(<span class="dv">3</span><span class="op">*</span>m), <span class="dt">nrow =</span> <span class="dv">3</span>)
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
    mnorm =<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dt">n =</span> <span class="dv">100</span>, <span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">2</span>), Sigma)
    x =<span class="st"> </span>mnorm[,<span class="dv">1</span>]
    y =<span class="st"> </span>mnorm[,<span class="dv">2</span>]
    result[<span class="dv">1</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x,y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'pearson'</span>)<span class="op">$</span>p.value
    result[<span class="dv">2</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x, y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'kendal'</span>)<span class="op">$</span>p.value
    result[<span class="dv">3</span>,i] =<span class="st"> </span><span class="kw">cor.test</span>(x, y, <span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">'spearman'</span>)<span class="op">$</span>p.value
  }
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>){
    <span class="kw">print</span>(<span class="kw">mean</span>(result[i,]<span class="op">&lt;=</span><span class="fl">0.05</span>))
  }
}
<span class="co">#&gt; [1] 0.187</span>
<span class="co">#&gt; [1] 0.168</span>
<span class="co">#&gt; [1] 0.169</span>
<span class="co">#&gt; [1] 0.527</span>
<span class="co">#&gt; [1] 0.484</span>
<span class="co">#&gt; [1] 0.497</span>
<span class="co">#&gt; [1] 0.866</span>
<span class="co">#&gt; [1] 0.823</span>
<span class="co">#&gt; [1] 0.83</span>
<span class="co">#&gt; [1] 0.985</span>
<span class="co">#&gt; [1] 0.974</span>
<span class="co">#&gt; [1] 0.974</span>
<span class="co">#&gt; [1] 0.998</span>
<span class="co">#&gt; [1] 0.999</span>
<span class="co">#&gt; [1] 0.999</span></code></pre></div>
</div>
</div>
<div id="this-is-the-work-in-2018.11.2" class="section level2">
<h2>This is the work in 2018.11.2</h2>
<div id="section-2" class="section level3">
<h3>7.1</h3>
<p>Compute a jackknife estimate of the bias and the standard error of the correlation statistic in Example 7.2</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bootstrap)
n =<span class="st"> </span><span class="kw">length</span>(law<span class="op">$</span>GPA)
cor.jack =<span class="st"> </span><span class="kw">numeric</span>(n)
cor =<span class="st"> </span><span class="kw">cor</span>(law<span class="op">$</span>LSAT, law<span class="op">$</span>GPA)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n)
  cor.jack[i] =<span class="st"> </span><span class="kw">cor</span>(law<span class="op">$</span>LSAT[<span class="op">-</span>i], law<span class="op">$</span>GPA[<span class="op">-</span>i])
bias.jack =<span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(<span class="kw">mean</span>(cor.jack)<span class="op">-</span>cor)
var.jack =<span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>n<span class="op">*</span><span class="kw">var</span>(cor.jack)
se.jack =<span class="st"> </span><span class="kw">sqrt</span>(var.jack)
bias.jack
<span class="co">#&gt; [1] -0.006473623</span>
se.jack
<span class="co">#&gt; [1] 0.1425186</span></code></pre></div>
<p><em>anaylysis</em></p>
<p>We can compare our result with the result in bootstrap</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">B =<span class="st"> </span><span class="dv">200</span>
n =<span class="st"> </span><span class="kw">nrow</span>(law)
R =<span class="st"> </span><span class="kw">numeric</span>(B)
<span class="cf">for</span>(b <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>B){
  i =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>n, <span class="dt">size =</span> n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
  LSAT =<span class="st"> </span>law<span class="op">$</span>LSAT[i]
  GPA =<span class="st"> </span>law<span class="op">$</span>GPA[i]
  R[b] =<span class="st"> </span><span class="kw">cor</span>(LSAT, GPA)
}
se.boot =<span class="st"> </span><span class="kw">sd</span>(R)
bias.boot =<span class="st"> </span><span class="kw">mean</span>(R)<span class="op">-</span>cor
se.boot
<span class="co">#&gt; [1] 0.1208434</span>
bias.boot
<span class="co">#&gt; [1] 0.00647718</span></code></pre></div>
<p>the results are almost the same, so we can conclude that our result is right.</p>
</div>
<div id="section-3" class="section level3">
<h3>7.5</h3>
<p>Refer to Exercise 7.4. Compute 95% bootstrap confidence intervals for the mean time between failures 1/?? by the standard normal, basic, percentile, and BCa methods. Compare the intervals and explain why they may differ.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(boot)
boot.mean =<span class="st"> </span><span class="cf">function</span>(x,i) <span class="kw">mean</span>(x[i,])
ci.norm&lt;-ci.basic&lt;-ci.perc&lt;-ci.bca&lt;-<span class="kw">matrix</span>(<span class="ot">NA</span>,<span class="dv">1</span>,<span class="dv">2</span>)
de &lt;-<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data=</span>aircondit,<span class="dt">statistic=</span>boot.mean, <span class="dt">R =</span> <span class="dv">999</span>)
ci &lt;-<span class="st"> </span><span class="kw">boot.ci</span>(de,<span class="dt">type=</span><span class="kw">c</span>(<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;basic&quot;</span>,<span class="st">&quot;perc&quot;</span>,<span class="st">&quot;bca&quot;</span>))
ci.norm[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>norm[<span class="dv">2</span><span class="op">:</span><span class="dv">3</span>]
ci.basic[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>basic[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
ci.perc[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>percent[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
ci.bca[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>bca[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
<span class="kw">cat</span>(<span class="st">'norm ='</span>,ci.norm[<span class="dv">1</span>,], <span class="st">'basic ='</span>,ci.basic[<span class="dv">1</span>,], <span class="st">'perc ='</span>,ci.perc[<span class="dv">1</span>,], <span class="st">'BCa ='</span>,ci.bca[<span class="dv">1</span>,])
<span class="co">#&gt; norm = 32.53654 182.7234 basic = 24.5 171.8333 perc = 44.33333 191.6667 BCa = 56.38654 233.3245</span></code></pre></div>
<p><em>analysis</em> Let’s do an interesting simulation. We generate random numbers from <span class="math inline">\(exp(\lambda)\)</span>, then compare the coverage rate of the above four intervals.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lambda =<span class="st"> </span><span class="fl">0.1</span>
m =<span class="st"> </span><span class="fl">1e2</span>
n =<span class="st"> </span><span class="fl">1e2</span> ##iteration numbers
data.simu =<span class="st"> </span><span class="kw">rexp</span>(m, lambda)
cover.norm =<span class="st"> </span>cover.basic =<span class="st"> </span>cover.perc =<span class="st"> </span>cover.bca =<span class="dv">0</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">boot.mean =<span class="st"> </span><span class="cf">function</span>(x,i) <span class="kw">mean</span>(x[i])
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){
  de &lt;-<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data =</span> data.simu,<span class="dt">statistic=</span>boot.mean, <span class="dt">R =</span> <span class="dv">999</span>)
  ci &lt;-<span class="st"> </span><span class="kw">boot.ci</span>(de,<span class="dt">type=</span><span class="kw">c</span>(<span class="st">&quot;norm&quot;</span>,<span class="st">&quot;basic&quot;</span>,<span class="st">&quot;perc&quot;</span>,<span class="st">&quot;bca&quot;</span>))
  ci.norm[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>norm[<span class="dv">2</span><span class="op">:</span><span class="dv">3</span>]
  ci.basic[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>basic[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
  ci.perc[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>percent[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
  ci.bca[<span class="dv">1</span>,]&lt;-ci<span class="op">$</span>bca[<span class="dv">4</span><span class="op">:</span><span class="dv">5</span>]
  cover.norm =<span class="st"> </span>cover.norm<span class="op">+</span><span class="kw">I</span>(ci.norm[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">&lt;=</span><span class="dv">1</span><span class="op">/</span>lambda <span class="op">&amp;</span><span class="st"> </span><span class="dv">1</span><span class="op">/</span>lambda<span class="op">&lt;=</span>ci.norm[<span class="dv">1</span>,<span class="dv">2</span>])
  cover.basic =<span class="st"> </span>cover.basic<span class="op">+</span><span class="kw">I</span>(ci.basic[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">&lt;=</span><span class="dv">1</span><span class="op">/</span>lambda <span class="op">&amp;</span><span class="st"> </span><span class="dv">1</span><span class="op">/</span>lambda<span class="op">&lt;=</span>ci.basic[<span class="dv">1</span>,<span class="dv">2</span>])
  cover.perc =<span class="st"> </span>cover.perc<span class="op">+</span><span class="kw">I</span>(ci.perc[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">&lt;=</span><span class="dv">1</span><span class="op">/</span>lambda <span class="op">&amp;</span><span class="st"> </span><span class="dv">1</span><span class="op">/</span>lambda<span class="op">&lt;=</span>ci.perc[<span class="dv">1</span>,<span class="dv">2</span>])
  cover.bca =<span class="st"> </span>cover.bca<span class="op">+</span><span class="kw">I</span>(ci.bca[<span class="dv">1</span>,<span class="dv">1</span>]<span class="op">&lt;=</span><span class="dv">1</span><span class="op">/</span>lambda <span class="op">&amp;</span><span class="st"> </span><span class="dv">1</span><span class="op">/</span>lambda<span class="op">&lt;=</span>ci.bca[<span class="dv">1</span>,<span class="dv">2</span>])
}
cover.norm<span class="op">/</span>n
<span class="co">#&gt; [1] 1</span>
cover.basic<span class="op">/</span>n
<span class="co">#&gt; [1] 1</span>
cover.perc<span class="op">/</span>n
<span class="co">#&gt; [1] 1</span>
cover.bca<span class="op">/</span>n
<span class="co">#&gt; [1] 1</span></code></pre></div>
<p>Well it’s hard to find the difference of the four intervals in this simulation.</p>
<p>But I am willing to believe that the BCa will perform better at most of the time. Since other interval has some assumpations of the data. And the BCa interval also compensate other things.</p>
</div>
<div id="section-4" class="section level3">
<h3>7.8</h3>
<p>Refer to Exercise 7.7. Obtain the jackknife estimates of bias and standaed error of <span class="math inline">\(\hat \theta\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">co =<span class="st"> </span><span class="kw">cov</span>(scor)
n =<span class="st"> </span><span class="kw">length</span>(scor<span class="op">$</span>mec)
eig =<span class="st"> </span><span class="kw">eigen</span>(co)<span class="op">$</span>values
theta =<span class="st"> </span>eig[<span class="dv">1</span>]<span class="op">/</span><span class="kw">sum</span>(eig)
theta.jack =<span class="st"> </span><span class="kw">numeric</span>(n)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){
  co =<span class="st"> </span><span class="kw">cov</span>(scor[<span class="op">-</span>i,])
  eig =<span class="st"> </span><span class="kw">eigen</span>(co)<span class="op">$</span>values
  theta.jack[i] =<span class="st"> </span>eig[<span class="dv">1</span>]<span class="op">/</span><span class="kw">sum</span>(eig)
}
bias.jack =<span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(<span class="kw">mean</span>(theta.jack)<span class="op">-</span>theta)
var.jack =<span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>n<span class="op">*</span><span class="kw">var</span>(theta.jack)
se.jack =<span class="st"> </span><span class="kw">sqrt</span>(var.jack)
bias.jack
<span class="co">#&gt; [1] 0.001069139</span>
se.jack
<span class="co">#&gt; [1] 0.04955231</span></code></pre></div>
<p><em>analysis</em> We can hope the jackknife can work because the statistic it estimates is smooth. The assumption which make the jackknife work is satisfied in this problem since the covariance is a smooth statistic. And also I will compare it to the bootstrap method.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">B =<span class="st"> </span><span class="dv">200</span>
theta.boot =<span class="st"> </span><span class="kw">numeric</span>(B)
<span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>B){
  i =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span>n, n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
  co =<span class="st"> </span><span class="kw">cov</span>(scor[i,])
  eig =<span class="st"> </span><span class="kw">eigen</span>(co)<span class="op">$</span>values
  theta.boot[j] =<span class="st"> </span>eig[<span class="dv">1</span>]<span class="op">/</span><span class="kw">sum</span>(eig)
}
bias.boot =<span class="st"> </span><span class="kw">mean</span>(theta.boot)<span class="op">-</span>theta
se.boot =<span class="st"> </span><span class="kw">sd</span>(theta.boot)
bias.boot
<span class="co">#&gt; [1] -0.000801137</span>
se.boot
<span class="co">#&gt; [1] 0.04341906</span></code></pre></div>
<p>So it turns out that our result is correct.</p>
</div>
<div id="section-5" class="section level3">
<h3>7.11</h3>
<p>In example 7.18, leave-one-out(n-fold)cross validation was used to select the best fitting model. Use leave-two-out cross validation to compare the models.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(DAAG)
<span class="co">#&gt; Warning: 程辑包'DAAG'是用R版本3.4.4 来建造的</span>
<span class="co">#&gt; 载入需要的程辑包：lattice</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; 载入程辑包：'lattice'</span>
<span class="co">#&gt; The following object is masked from 'package:boot':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     melanoma</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; 载入程辑包：'DAAG'</span>
<span class="co">#&gt; The following object is masked from 'package:MASS':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     hills</span>
chemical =<span class="st"> </span>ironslag<span class="op">$</span>chemical
magnetic =<span class="st"> </span>ironslag<span class="op">$</span>magnetic
n =<span class="st"> </span><span class="kw">length</span>(magnetic)
e1 &lt;-<span class="st"> </span>e2 &lt;-<span class="st"> </span>e3 &lt;-<span class="st"> </span>e4 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> n, <span class="dt">ncol =</span> n)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(n<span class="op">-</span><span class="dv">1</span>))
  <span class="cf">for</span>(j <span class="cf">in</span> (i<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n){
    y =<span class="st"> </span>magnetic[<span class="kw">c</span>(<span class="op">-</span>i, <span class="op">-</span>j)]
    x =<span class="st"> </span>chemical[<span class="kw">c</span>(<span class="op">-</span>i, <span class="op">-</span>j)]
    J1 =<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x)
    yhat1 =<span class="st"> </span>J1<span class="op">$</span>coef[<span class="dv">1</span>]<span class="op">+</span>J1<span class="op">$</span>coef[<span class="dv">2</span>]<span class="op">*</span>chemical[<span class="kw">c</span>(i,j)]
    e1[i,j] =<span class="st"> </span><span class="kw">mean</span>((magnetic[<span class="kw">c</span>(i,j)]<span class="op">-</span>yhat1)<span class="op">^</span><span class="dv">2</span>)
    
    J2 =<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x<span class="op">+</span><span class="kw">I</span>(x<span class="op">^</span><span class="dv">2</span>))
    yhat2 =<span class="st"> </span>J2<span class="op">$</span>coef[<span class="dv">1</span>]<span class="op">+</span>J2<span class="op">$</span>coef[<span class="dv">2</span>]<span class="op">*</span>chemical[<span class="kw">c</span>(i,j)]<span class="op">+</span>J2<span class="op">$</span>coef[<span class="dv">3</span>]<span class="op">*</span>chemical[<span class="kw">c</span>(i,j)]<span class="op">^</span><span class="dv">2</span>
    e2[i,j] =<span class="st"> </span><span class="kw">mean</span>((magnetic[<span class="kw">c</span>(i,j)]<span class="op">-</span>yhat2)<span class="op">^</span><span class="dv">2</span>)
    
    J3 =<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span>x)
    logyhat3 =<span class="st"> </span>J3<span class="op">$</span>coef[<span class="dv">1</span>]<span class="op">+</span>J3<span class="op">$</span>coef[<span class="dv">2</span>]<span class="op">*</span>chemical[<span class="kw">c</span>(i,j)]
    yhat3 =<span class="st"> </span><span class="kw">exp</span>(logyhat3)
    e3[i,j] =<span class="st"> </span><span class="kw">mean</span>((magnetic[<span class="kw">c</span>(i,j)]<span class="op">-</span>yhat3)<span class="op">^</span><span class="dv">2</span>)
    
    J4 =<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(x))
    logyhat4 =<span class="st"> </span>J4<span class="op">$</span>coef[<span class="dv">1</span>]<span class="op">+</span>J4<span class="op">$</span>coef[<span class="dv">2</span>]<span class="op">*</span><span class="kw">log</span>(chemical[<span class="kw">c</span>(i,j)])
    yhat4 =<span class="st"> </span><span class="kw">exp</span>(logyhat4)
    e4[i,j] =<span class="st"> </span><span class="kw">mean</span>((magnetic[<span class="kw">c</span>(i,j)]<span class="op">-</span>yhat4)<span class="op">^</span><span class="dv">2</span>)
    
  }
<span class="kw">c</span>(<span class="dv">2</span><span class="op">/</span>(n<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>))<span class="op">*</span><span class="kw">sum</span>(e1),<span class="dv">2</span><span class="op">/</span>(n<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>))<span class="op">*</span><span class="kw">sum</span>(e2),<span class="dv">2</span><span class="op">/</span>(n<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>))<span class="op">*</span><span class="kw">sum</span>(e3),<span class="dv">2</span><span class="op">/</span>(n<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>))<span class="op">*</span><span class="kw">sum</span>(e4))
<span class="co">#&gt; [1] 19.57227 17.87018 18.45491 20.46718</span></code></pre></div>
<p><em>analysis</em> Through this result , we can conclude that we will choose the second model, which is conincide with the leave-one-out cross-validation. So we can also use leave-two-out validation to do the model selection.</p>
</div>
</div>
<div id="this-is-the-work-in-2018.11.16" class="section level2">
<h2>This is the work in 2018.11.16</h2>
<div id="section-6" class="section level3">
<h3>8.1</h3>
<p>Implement the twp-sample Cramer-con Mises test for equal distribution permutation test. Apply the test to the data in Example 8.1 and 8.2</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(chickwts)
X =<span class="st"> </span><span class="kw">sort</span>(<span class="kw">as.vector</span>(weight[feed <span class="op">==</span><span class="st"> &quot;soybean&quot;</span>]))
Y =<span class="st"> </span><span class="kw">sort</span>(<span class="kw">as.vector</span>(weight[feed <span class="op">==</span><span class="st"> 'linseed'</span>]))
R =<span class="st"> </span><span class="dv">999</span>
z =<span class="st"> </span><span class="kw">c</span>(X,Y)
K =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">26</span>
n =<span class="st"> </span><span class="kw">length</span>(X)
m =<span class="st"> </span><span class="kw">length</span>(Y)
reps =<span class="st"> </span><span class="kw">numeric</span>(R)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">CMstat =<span class="st"> </span><span class="cf">function</span>(x,y){
  x =<span class="st"> </span><span class="kw">sort</span>(x)
  y =<span class="st"> </span><span class="kw">sort</span>(y)
  F =<span class="st"> </span><span class="cf">function</span>(x0){
    
    <span class="kw">findInterval</span>(x0, x)<span class="op">/</span>n
  }
  G =<span class="st"> </span><span class="cf">function</span>(y0){
    <span class="kw">findInterval</span>(y0, y)<span class="op">/</span>m
  }
  m<span class="op">*</span>n<span class="op">/</span>(m<span class="op">+</span>n)<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(<span class="kw">sum</span>((<span class="kw">F</span>(x)<span class="op">-</span><span class="kw">G</span>(x))<span class="op">^</span><span class="dv">2</span>)<span class="op">+</span><span class="kw">sum</span>((<span class="kw">F</span>(y)<span class="op">-</span><span class="kw">G</span>(y))<span class="op">^</span><span class="dv">2</span>))
}
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>R){
  k =<span class="st"> </span><span class="kw">sample</span>(K, <span class="dt">size =</span> n, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
  x1 =<span class="st"> </span>z[k]
  y1 =<span class="st"> </span>z[<span class="op">-</span>k]
  reps[i] =<span class="st"> </span><span class="kw">CMstat</span>(x1, y1)
  t0 =<span class="st"> </span><span class="kw">CMstat</span>(X,Y)
  p.value =<span class="st"> </span><span class="kw">mean</span>(<span class="kw">c</span>(t0, reps)<span class="op">&gt;=</span>t0)
}
p.value
<span class="co">#&gt; [1] 0.364</span></code></pre></div>
</div>
<div id="section-7" class="section level3">
<h3>2</h3>
<p>Design experiments for evaluating the performance of the NN, energy and ball methods in different situations.</p>
<p><em>1. unequal variance but equal expectations</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(RANN)
<span class="co">#&gt; Warning: 程辑包'RANN'是用R版本3.4.4 来建造的</span>
<span class="kw">library</span>(boot)
<span class="kw">library</span>(energy)
<span class="co">#&gt; Warning: 程辑包'energy'是用R版本3.4.4 来建造的</span>
<span class="kw">library</span>(Ball)
<span class="co">#&gt; Warning: 程辑包'Ball'是用R版本3.4.4 来建造的</span>
<span class="co">#&gt; 载入需要的程辑包：gam</span>
<span class="co">#&gt; Warning: 程辑包'gam'是用R版本3.4.4 来建造的</span>
<span class="co">#&gt; 载入需要的程辑包：splines</span>
<span class="co">#&gt; 载入需要的程辑包：foreach</span>
<span class="co">#&gt; Warning: 程辑包'foreach'是用R版本3.4.4 来建造的</span>
<span class="co">#&gt; Loaded gam 1.16</span>
<span class="co">#&gt; 载入需要的程辑包：survival</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; 载入程辑包：'survival'</span>
<span class="co">#&gt; The following object is masked from 'package:DAAG':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     lung</span>
<span class="co">#&gt; The following object is masked from 'package:boot':</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     aml</span>
<span class="co">#&gt; 载入需要的程辑包：mvtnorm</span>
<span class="co">#&gt; Warning: 程辑包'mvtnorm'是用R版本3.4.4 来建造的</span>
n1 =<span class="st"> </span><span class="dv">50</span>
n2 =<span class="st"> </span><span class="dv">30</span>
p =<span class="st"> </span><span class="dv">2</span>
m =<span class="st"> </span><span class="dv">200</span>
k =<span class="st"> </span><span class="dv">3</span>
R =<span class="st"> </span><span class="dv">200</span>
n =<span class="st"> </span>n1<span class="op">+</span>n2
N =<span class="st"> </span><span class="kw">c</span>(n1, n2)

Tn =<span class="st"> </span><span class="cf">function</span>(z, ix, sizes, k){
  n1 =<span class="st"> </span>sizes[<span class="dv">1</span>]
  n2 =<span class="st"> </span>sizes[<span class="dv">2</span>]
  z =<span class="st"> </span>z[ix, ]
  NN =<span class="st"> </span><span class="kw">nn2</span>(<span class="dt">data =</span> z, <span class="dt">k =</span> k<span class="op">+</span><span class="dv">1</span>)
  block1 =<span class="st"> </span>NN<span class="op">$</span>nn.idx[<span class="dv">1</span><span class="op">:</span>n1, <span class="op">-</span><span class="dv">1</span>]
  block2 =<span class="st"> </span>NN<span class="op">$</span>nn.idx[(n1<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n, <span class="op">-</span><span class="dv">1</span>]
  i1 =<span class="st"> </span><span class="kw">sum</span>(block1 <span class="op">&lt;</span><span class="st"> </span>n1<span class="op">+</span>.<span class="dv">5</span>)
  i2 =<span class="st"> </span><span class="kw">sum</span>(block2 <span class="op">&gt;</span><span class="st"> </span>n1<span class="op">+</span>.<span class="dv">5</span>)
  (i1<span class="op">+</span>i2)<span class="op">/</span>(k<span class="op">*</span>n)
}

eqdist.nn =<span class="st"> </span><span class="cf">function</span>(z, sizes, k, R){
  boot.obj =<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data =</span> Z, <span class="dt">statistic =</span> Tn, <span class="dt">R =</span> R, <span class="dt">sim =</span> <span class="st">'permutation'</span>, <span class="dt">sizes =</span> sizes, <span class="dt">k =</span> <span class="dv">3</span>)
  ts =<span class="st"> </span><span class="kw">c</span>(boot.obj<span class="op">$</span>t0, boot.obj<span class="op">$</span>t)
  p.value =<span class="st"> </span><span class="kw">mean</span>(ts<span class="op">&gt;=</span>ts[<span class="dv">1</span>])
  <span class="kw">list</span>(<span class="dt">statistic =</span> ts[<span class="dv">1</span>], <span class="dt">p.value =</span> p.value)
}

p.values =<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, m ,<span class="dv">3</span>)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  X =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p), <span class="dt">ncol =</span> p)
  Y =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2), <span class="kw">rnorm</span>(n2, <span class="dt">sd =</span> <span class="fl">1.5</span>))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.05</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.180 0.135 0.330</span></code></pre></div>
<p>From the result we con conclude that the Ball method is more powerful than the other two.</p>
<p><em>2. unequal mean and unequal variance</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  X =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p), <span class="dt">ncol =</span> p)
  Y =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2, <span class="dt">mean =</span> <span class="fl">0.5</span>), <span class="kw">rnorm</span>(n2, <span class="dt">sd =</span> <span class="fl">1.5</span>))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.05</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.335 0.570 0.525</span></code></pre></div>
<p>Then we will see what would happen if we narrow down the difference of the mean.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  X =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p), <span class="dt">ncol =</span> p)
  Y =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2, <span class="dt">mean =</span> <span class="fl">0.1</span>), <span class="kw">rnorm</span>(n2, <span class="dt">sd =</span> <span class="fl">1.5</span>))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.05</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.21 0.17 0.33</span></code></pre></div>
<p>We can see as the difference of the mean becomes much smaller, the differece of the variance becomes dominate, than the power of the Ball extimation leads again.</p>
<p>To make the result more significant, we will change the parameter as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  X =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p), <span class="dt">ncol =</span> p)
  Y =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2, <span class="dt">mean =</span> <span class="fl">0.3</span>, <span class="dt">sd =</span> <span class="fl">1.3</span>), <span class="kw">rnorm</span>(n2, <span class="dt">sd =</span> <span class="fl">1.5</span>))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.05</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.315 0.380 0.650</span></code></pre></div>
<p>In this example, we can see the power of the Ball parameter is much higher than the other two, this shows the advantage of the Ball parameter, more sensitive to the change of variance.</p>
<p><em>3. Non-normal distributions</em></p>
<p>t distribution with different degree of freedom</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  X =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rt</span>(n1<span class="op">*</span>p, <span class="dt">df =</span> <span class="dv">1</span>), <span class="dt">ncol =</span> p)
  Y =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rt</span>(n2, <span class="dt">df =</span> <span class="dv">2</span>), <span class="kw">rt</span>(n2, <span class="dt">df =</span> <span class="dv">3</span>))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.1</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.175 0.320 0.750</span></code></pre></div>
<p>From the result we can see that the Ball statistic is much more powerful than the other two.</p>
<p>Since t distribution with differnet means are somewhat very likely to the normal distribution with diffenret mean, so we omit it here</p>
<p>Mixture Normal</p>
<p>First, unequal mixture probability and equal mean and eqaul variance</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  p1 =<span class="st"> </span><span class="fl">0.7</span>
  p2 =<span class="st"> </span><span class="fl">0.3</span>
  U1 =<span class="st"> </span><span class="kw">runif</span>(n1)
  U2 =<span class="st"> </span><span class="kw">runif</span>(n2)
  X =<span class="st"> </span>((U1<span class="op">&lt;</span>p1)<span class="op">*</span><span class="kw">mvrnorm</span>(n1, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="dt">Sigma =</span> <span class="kw">diag</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>)))<span class="op">+</span>(<span class="dv">1</span><span class="op">-</span>(U1<span class="op">&lt;</span>p1))<span class="op">*</span><span class="kw">mvrnorm</span>(n1, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">Sigma =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="fl">1.3</span>,<span class="fl">1.3</span>,<span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)))
  Y =<span class="st"> </span>((U2<span class="op">&lt;</span>p2)<span class="op">*</span><span class="kw">mvrnorm</span>(n2, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="dt">Sigma =</span> <span class="kw">diag</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>)))<span class="op">+</span>(<span class="dv">1</span><span class="op">-</span>(U2<span class="op">&lt;</span>p2))<span class="op">*</span><span class="kw">mvrnorm</span>(n2, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">Sigma =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="fl">1.3</span>,<span class="fl">1.3</span>,<span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.1</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.235 0.500 0.420</span></code></pre></div>
<p>We can see that the Energy method and the Ball method has comparable power, and the power of NN is much lower.</p>
<p>equal mixture probability, but different mean and variance</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  p1 =<span class="st"> </span><span class="fl">0.4</span>
  p2 =<span class="st"> </span><span class="fl">0.4</span>
  U1 =<span class="st"> </span><span class="kw">runif</span>(n1)
  U2 =<span class="st"> </span><span class="kw">runif</span>(n2)
  X =<span class="st"> </span>((U1<span class="op">&lt;</span>p1)<span class="op">*</span><span class="kw">mvrnorm</span>(n1, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="dt">Sigma =</span> <span class="kw">diag</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>)))<span class="op">+</span>(<span class="dv">1</span><span class="op">-</span>(U1<span class="op">&lt;</span>p1))<span class="op">*</span><span class="kw">mvrnorm</span>(n1, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), <span class="dt">Sigma =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)))
  Y =<span class="st"> </span>((U2<span class="op">&lt;</span>p2)<span class="op">*</span><span class="kw">mvrnorm</span>(n2, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="fl">0.5</span>,<span class="dv">0</span>), <span class="dt">Sigma =</span> <span class="kw">diag</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>)))<span class="op">+</span>(<span class="dv">1</span><span class="op">-</span>(U2<span class="op">&lt;</span>p2))<span class="op">*</span><span class="kw">mvrnorm</span>(n2, <span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="fl">1.2</span>), <span class="dt">Sigma =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">2</span>,<span class="fl">1.3</span>,<span class="fl">1.3</span>,<span class="dv">1</span>), <span class="dt">nrow =</span> <span class="dv">2</span>)))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.1</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.405 0.240 0.260</span></code></pre></div>
<p>We can see that in this situation, the NN method finnaly makes it the best one, while the Ball method and the energy method has similar power.</p>
<p><em>4. unbalanced samples</em></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n1 =<span class="st"> </span><span class="dv">100</span>
n2 =<span class="st"> </span><span class="dv">10</span>
N =<span class="st"> </span><span class="kw">c</span>(n1, n2)
n =<span class="st"> </span>n1<span class="op">+</span>n2
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  X =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p), <span class="dt">ncol =</span> p)
  Y =<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2), <span class="kw">rnorm</span>(n2, <span class="dt">mean =</span> <span class="fl">0.5</span>,<span class="dt">sd =</span> <span class="fl">1.8</span>))
  Z =<span class="st"> </span><span class="kw">rbind</span>(X, Y)
  p.values[i,<span class="dv">1</span>] =<span class="st"> </span><span class="kw">eqdist.nn</span>(Z, <span class="dt">sizes =</span> N, k, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">2</span>] =<span class="st"> </span><span class="kw">eqdist.etest</span>(Z, <span class="dt">sizes =</span> N, <span class="dt">R =</span> R)<span class="op">$</span>p.value
  p.values[i,<span class="dv">3</span>] =<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x =</span> X, <span class="dt">y =</span> Y, <span class="dt">R =</span> R, <span class="dt">seed =</span> i)<span class="op">$</span>p.value
}
alpha =<span class="st"> </span><span class="fl">0.1</span>
pow =<span class="st"> </span><span class="kw">colMeans</span>(p.values<span class="op">&lt;</span>alpha)
pow
<span class="co">#&gt; [1] 0.39 0.49 0.32</span></code></pre></div>
<p>I try many parameters but hard to find significance difference between the three method. And the result above is a rather significant result compared to other result. It seems the energy test can show more power when the number of samples is rather unbalanced. And it turns out that it’s a rather tough task for all the three methods, the powers they show are much smaller than when the sample is balanced.</p>
<p><em>Analysis</em></p>
<p>So in conclusion, the Ball method usually shows much more powerful than the other two methods, especially when we are under the situation the variance is different or the distribution has a heavy tail. And we can see that NN usually shows the leat powerful performance. And the Energy method’s power is usually betweeen the other two, and sometimes can be the top one, like the the last situation and the mixture model situation.</p>
</div>
<div id="section-8" class="section level3">
<h3>9.3</h3>
<p>Use the Metropolis-Hastings sampler to generate random variables from a standard Cauchy distribution. Discard the ???rst 1000 of the chain, and compare the deciles of the generated observations with the deciles of the standard Cauchy distribution (see qcauchy or qt with df=1). Recall that a Cauchy(??,??) distribution has density function <span class="math inline">\(f(x) = \frac{1}{\theta\pi(1+\frac{x-\eta}{\theta})^2}\)</span> The standard Cauchy has the Cauchy(?? =1,??= 0) density. (Note that the standard Cauchy density is equal to the Student t density with one degree of freedom.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">burnin =<span class="st"> </span><span class="dv">4000</span>
N =<span class="st"> </span><span class="dv">100000</span>
rw.Metropolis =<span class="st"> </span><span class="cf">function</span>(n, sigma, x0, N){
  x =<span class="st"> </span><span class="kw">numeric</span>(N)
  x[<span class="dv">1</span>] =<span class="st"> </span>x0
  u =<span class="st"> </span><span class="kw">runif</span>(N)
  k =<span class="st"> </span><span class="dv">0</span>
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N){
    y =<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, x[i<span class="op">-</span><span class="dv">1</span>], sigma)
    <span class="cf">if</span>(u[i]<span class="op">&lt;=</span>(<span class="kw">dt</span>(y, n)<span class="op">/</span><span class="kw">dt</span>(x[i<span class="op">-</span><span class="dv">1</span>], n))){
      x[i] =<span class="st"> </span>y
      k =<span class="st"> </span>k<span class="op">+</span><span class="dv">1</span>
    }<span class="cf">else</span>{
      x[i] =<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
    }
  }
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">x =</span> x, <span class="dt">k=</span>k))
}

result =<span class="st"> </span><span class="kw">rw.Metropolis</span>(<span class="dt">n =</span> <span class="dv">1</span>, <span class="dt">sigma =</span> <span class="fl">0.9</span>, <span class="dt">x0 =</span> <span class="dv">25</span>, <span class="dt">N =</span> N)
simulation =<span class="st"> </span>result<span class="op">$</span>x[(burnin<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>N]

quant.simu =<span class="st"> </span><span class="kw">quantile</span>(simulation, (<span class="dv">5</span><span class="op">:</span><span class="dv">95</span>)<span class="op">/</span><span class="dv">100</span>)
quant.true =<span class="st"> </span><span class="kw">qcauchy</span>((<span class="dv">5</span><span class="op">:</span><span class="dv">95</span>)<span class="op">/</span><span class="dv">100</span>)
<span class="kw">plot</span>(quant.simu, quant.true)
g =<span class="st"> </span><span class="cf">function</span>(x) x
<span class="kw">curve</span>(g, <span class="op">-</span><span class="dv">6</span>,<span class="dv">6</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>, )</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAWlBMVEUAAAAAADoAAGYAOpAAZrY6AAA6ADo6AGY6kNtmAABmADpmkJBmtrZmtv+QOgCQZgCQtpCQ2/+2ZgC225C2/7a2///bkDrb/9vb////tmb/25D//7b//9v////lwtI/AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAJBElEQVR4nO2di3aqOBhG09p2dObYM3WmTKnl/V9zSAKISvLlSqJ++6xaV4Uk7pMb4QdER6yI0gWoHQoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBEgsSNwMpQSlTS4DgxsKMiBmP847JM6/ZsT4mknQ4fmz+34V4ukjSXLrk1mQ8vPWyznu9gmSK0BeQcfdtpf0It82m6/o5IqQtQ+S9ebnfSvftn1dmqfiPXoWI+soJmtPc9s1aCDTPOi4e/5UVag19dK3IajXk2uYb3VDekmU3EpcNH3Ogy44F8KZ9CVi9jp1PhR0Qly9dhQ056Rm1hVR0IyhDzrrqSlIMo5e6vd50SioOx+9LmeGFHTWLV9PnCnorHM2feicSjJqFLR43PXogqZu2bTAECLouBObr8M2rmBReydjGtiNR+0Bgvoj9GbzpRbF/AtU13rQad3QWB5/QXIZQ67yNOdLYUFFK81s9mPfxDmtTi8XSkHtjQsS02KPtSzhNehgWCv0TK4Uuvextq5pO+cENboPaoThfIVvcmWYGhfqDQNHMcsZL+/kCjAuyDuU4iHnQbphuS04P6AgXX2uj9sNWzsnO75RDUxyo6OY0P9c52LBNShulC8mSA/urtWni2liB+MpnaT5pmWoPJ37+a5wQTc4UZyqT47AsasNb+9Qw7/6dBGCjrsba2JC1xyv6tPFjGLWI42m30DNtE31bG1Bkxqv6tPlmgc1/TxbV7E6BOllMf/q04UerAL0Jj/vlkWRNQWNjcu/+nShyx2AcZP+gL8pH0A15RiUbcjRPBy+pkp2eCleg8Ss/oRkmudQY9TSb1tW0JmeoDwzHayOq0U/70UFxbUunYT3hsc/9UpQ/TPpU/WJ6PPCBdU+k55fkBKRm6+gwynTqBNj2QUl8hNRg+LILCiVnjtdURTp/Nzj0XxKPfdYg9L6uTtBifXc2zwouZ77mgeJDH7uaR6UQ88dzYPy6Fm9k87xFc7TTZ14gKCfd12KevqgfHqCBB3izql65uuSVj49YQtmceGbnvnilLL6ybMmnTJfmFBWPWFnNaLOGPrmC5LRWrLpCVu0jwu+88zXmkju6tPlWrRPmK8lifx2uls+WM3funQ2yTdcJ7l1qk8XJGhsY7Ymljt4YS09YRPFzVfz0n2/WrrqzMELK7UunZf3hnKi2MqwBHP8S97gBS1nHT2hE8XvPz7VjwFz8IJ/vlc7DhHOMWdLvfLz3lBWD7nkYRGUL3hBnMKgVtET1AfJ73zY2ppYtuCFUc8qjWvIMmDDw4vlm2tMwQtRQ8+p8wkN1QjJNPmG2ZIbAsRW1ZNXkC1Yzzs5XXvW1pP3WCyloNnAvqaeiBrkcFosnaCxZ1659qisgzfE12okExQUIp+IcEEesZxR+QoxdD0Fqk9Xf3SHUD+lqk8XIWidazXUZsMVgkX8RIxiUVeFO+U7a125oh0cCpF8w2TJDa2r61Y77jKVIu2GqZKbta60WfsRMVF0mStG5DtNm4v6CT/tk/fOC8NxaeHa0/kUYLYepM3Yljti89UdD9xsDQKaWP4QvEpa11gWzw3HGpTx7i+VtC5FSB+k7mvSBN3dBC6YjVMfn6JlJWSYV+NY3DzRlO/Q+dRTgSqbB01zwyq6H0VtgjzuqrEOlQmqqPMZqEpQVZ3PQEWCiq5qGKlEUB2TwiXqEFRsvRBThSBRyXHXEpkEeT0+a2hdjyTI6/FZTncMLUYWQT6Pz5paV51+cgkyPT7rMjkx/a7UT64m5vj4rFqtzMgjyO3xWfVOfmbkGuYNj8+arwdVPLbPKDgPuo1WllMQCF6gIAoCoPCXh++DYHzQI49ikqRBnKUoNordDIUEgRRX/izFl6MgAAUBKAhAQQAKAlAQgIIAFAS4mWODUlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCBAekEyhtFyabnpcit1M+LFE26tOSbSvJM1Lx+SC5L3QbNcfN8arif6ee8lNEtmZSySIR7JvJM1Ly9SC9KnXY23bzjuDIXWd99b2E8nuHxHEeNO9ry8SC1IBcGaaTa/bYVeqCl2CYadXPJyJLWg9vnfnblb6PVZ+4WFm35r47YraQ13Ckd5OZJaUCMvujfdelk2F1uh2wWzun4YgyKXd3LIy5Xkgp4s/+EyNtZS6NbUR9sELe6E83ImuSClZvmGp6q1mAu9XBVAEzPUH5SXOwkFyTvhbvU3ueqq1WfNEHmyX/hM/lr8qvZO2rCTTnQhL39S1yB9FYelTzX9r5ruiWEb5tGNNCqrQRrZ9m0xaIZCf7+adrFMFM07WfPyIv2hRmud/ZsKPTSJJRGN8VDDspMtLy94sAqgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFAaoX1J7HbxjvAZqL2gWtLuQSCgKUFiRjW/5++1Ae1MtBh4Udd792/RsZtq9jWOS7/gP1SOpX+dlW/kX/IafGwoJkCG8rnk6C1N1Q1VPbZRD98EE3ROK1Yq8FqQD7ftfm+fO+BQ0BiCdB6glD8q/qzsP9m/Grt9Njpvc6sGx42d+3oCnkc/4123nLGb+6vI2s/r3XWseX+xbUXAnq+6Tnf16vBekLe/aPJkgHZ84ETd/9SpDkoNviAwnSX0z1QbpHUW2uXWhi4+YLgramwPUkFB7F5IAlB6Wf981X34j2uvKI7UyQjphVda1dqEHjnrlKWHoeJIOG/3r7UM/u+qX7oKePw3zcF5v/5LUxrY73vRI07ZmJ0oIk4BqzslAQgIIANQiqGgoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQE+B8j8a73p4JUogAAAABJRU5ErkJggg==" /><!-- --></p>
<p>There is a slight deviation between in the hvery high percentile or very low percentile, I think the reason for this problem is that the data in these area are very sparse, since we use the sample quantile to approximate the true quantile , it will have some deviations. And the most important reason is that the <span class="math inline">\(t_1\)</span> distribution has very heavy tails(it even don’t have the expectation), so the high tail or low tail estimation will be very insteady. Even if we generate data from the true distribution, there will be some deviations, I will demonstrate below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data =<span class="st"> </span><span class="kw">rt</span>(<span class="dv">10000</span>, <span class="dt">df =</span> <span class="dv">1</span>)
quant.data =<span class="st"> </span><span class="kw">quantile</span>(data, (<span class="dv">5</span><span class="op">:</span><span class="dv">95</span>)<span class="op">/</span><span class="dv">100</span>)
quant.true =<span class="st"> </span><span class="kw">qcauchy</span>((<span class="dv">5</span><span class="op">:</span><span class="dv">95</span>)<span class="op">/</span><span class="dv">100</span>)
<span class="kw">plot</span>(quant.simu, quant.true)
g =<span class="st"> </span><span class="cf">function</span>(x) x
<span class="kw">curve</span>(g, <span class="op">-</span><span class="dv">6</span>,<span class="dv">6</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>, )</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --> That’s exactly the figure we get above.</p>
<p>Throught the figure we may draw the conclusion that the quantile between the simulation and the true quantile is the same, but to be more rigorous, I use the least sqaure method to find the slope.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">result =<span class="st"> </span><span class="kw">lm</span>(quant.true<span class="op">~</span>quant.simu)
result<span class="op">$</span>coefficients
<span class="co">#&gt; (Intercept)  quant.simu </span>
<span class="co">#&gt;  0.06709402  1.04685022</span></code></pre></div>
<p>What if we narrow down the quantile.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">quant.simu =<span class="st"> </span><span class="kw">quantile</span>(simulation, (<span class="dv">10</span><span class="op">:</span><span class="dv">90</span>)<span class="op">/</span><span class="dv">100</span>)
quant.true =<span class="st"> </span><span class="kw">qcauchy</span>((<span class="dv">10</span><span class="op">:</span><span class="dv">90</span>)<span class="op">/</span><span class="dv">100</span>)
result =<span class="st"> </span><span class="kw">lm</span>(quant.true<span class="op">~</span>quant.simu)
result<span class="op">$</span>coefficients
<span class="co">#&gt; (Intercept)  quant.simu </span>
<span class="co">#&gt;   0.0504123   1.0005263</span></code></pre></div>
<p>The result becomes more attractive.</p>
</div>
<div id="section-9" class="section level3">
<h3>9.6</h3>
<p>Rao presented an example on genetic linkage of 197 animals in four categories. The group sizes are(125, 18, 20, 34)??Assume that the probabilities of the corresponding multinomial distribution are <span class="math inline">\((\frac{1}{2}+\frac{\theta}{4}, \frac{1-\theta}{4}, \frac{1-\theta}{4}, \frac{\theta}{4})\)</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">N =<span class="st"> </span><span class="dv">10000</span>
burnin =<span class="st"> </span><span class="dv">2000</span>
w =<span class="st"> </span><span class="dv">1</span>
x =<span class="st"> </span><span class="kw">numeric</span>(N)
x[<span class="dv">1</span>] =<span class="st"> </span><span class="fl">0.5</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(y) {
  <span class="kw">I</span>(y<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>y<span class="op">&lt;</span><span class="dv">1</span>)<span class="op">*</span>(<span class="fl">0.5</span> <span class="op">+</span><span class="st"> </span>y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">125</span> <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">18</span> <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">20</span> <span class="op">*</span><span class="st"> </span>(y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">34</span>
}
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N) {
  k =<span class="st"> </span><span class="dv">0</span>
  u =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
  x1 =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>, <span class="dv">0</span>, w)
  <span class="cf">if</span>(u <span class="op">&lt;</span><span class="st"> </span><span class="kw">f</span>(x1)<span class="op">/</span><span class="kw">f</span>(x[i<span class="op">-</span><span class="dv">1</span>])){
    x[i] =<span class="st"> </span>x1
    k =<span class="st"> </span>k<span class="op">+</span><span class="dv">1</span>
  }
  <span class="cf">else</span> x[i] =<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
}

xp =<span class="st"> </span>x[(burnin<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>N]
beta =<span class="st"> </span><span class="kw">mean</span>(xp)
<span class="kw">print</span>(<span class="kw">round</span>(<span class="kw">c</span>(<span class="fl">0.5</span> <span class="op">+</span><span class="st"> </span>beta<span class="op">/</span><span class="dv">4</span>, (<span class="dv">1</span><span class="op">-</span>beta)<span class="op">/</span><span class="dv">4</span>, (<span class="dv">1</span><span class="op">-</span>beta)<span class="op">/</span><span class="dv">4</span>, beta<span class="op">/</span><span class="dv">4</span>), <span class="dv">3</span>))
<span class="co">#&gt; [1] 0.656 0.094 0.094 0.156</span>
<span class="kw">print</span>(<span class="kw">round</span>(<span class="kw">c</span>(<span class="dv">125</span>, <span class="dv">18</span>, <span class="dv">20</span>, <span class="dv">34</span>)<span class="op">/</span><span class="kw">sum</span>(<span class="kw">c</span>(<span class="dv">125</span>, <span class="dv">18</span>, <span class="dv">20</span>, <span class="dv">34</span>)),<span class="dv">3</span>))
<span class="co">#&gt; [1] 0.635 0.091 0.102 0.173</span>

<span class="kw">hist</span>(xp, <span class="dt">freq =</span> F)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>In order to check our result is true, we first see the process of x</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;x&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">1</span>, N), <span class="dt">ylim =</span> <span class="kw">range</span>(x))</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAXVBMVEUAAAAAADoAAGYAOpAAZrY6AAA6ADo6ZmY6kNtmAABmADpmOpBmZmZmtttmtv+QOgCQOmaQZgCQ2/+2ZgC2/7a2///bkDrb2//b/9vb////tmb/25D//7b//9v///8zy9NQAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAH40lEQVR4nO3dbWObNhSG4dM23Zq9JFu9eZubnP//MxeMEUJvjwQChP3cn5yAhLkKOHVMK8qSyd5PoPUIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEIBCIQiEAgAoEqA8lh2haofLt7tzHQWtOtF4FAzQPtLflwQKXztQskc7abPW3FGWdOvGg6UQIlZyZQFaDIwPQwAoFljw4kiWXu1FkdDggMJBCBhm/ZQOG1xR9KoMcDCu2lAySZQJIEknsEEskAsl/aZfiOP20KqOylcuGKH709f/kvdzoAJD7QZKg4LkcB+vnrt6zpZNjL6bJNgNKXwYxFM1fUDuibnuUpYzoXSIZvFgO5UlEgCQJFd281INWLJIxWBhL/Ap4NNH2/fEUgvRp9/js1nQckuh/Q8Jw2BILT5QKNL1fj+mKAJA4kZntJIJERplEguYHoCCRRoP5RBpBEgAzT8E1zGG4ClD9dCZDIYDJ8c1ycABoOFxnXcIFu84iBt5DaAxIHSAQByQAkFpBkAUkQSDYEOmdcpAUBiQckM4EEA93+RGT6RHF1jiD3V8/mENkHSCwge7r9gNzpRoDhydnnkAtkwRQCSRDIOqmOByQOkLhA0wJAw1GnOgUS84UNZP4gzOyF+10G9P7aby9yBcJAEgESBGQz6LAgASQ6AZJtgM5ifpSO/ES0HtC4SI3TCBYCcibaAOj91bCcI298zAeymVwg93vO2AmQu/aWQG/PL8PDC3iZ3xoI1vwR5J9NFYAig6JAsjLQxzXodggVXYNCR86dAn2cZP1Gom+9BoHCFplA8X0tArKGrwmUO114BysBBSYp6WhAZV+HdzkLxqzdLlDGvj0cUOm+le3rrEEPCFTWsYG26FBAe0QgEIFABAIRCESgW9G3hgjURyBQZaD3f3YACryFVq/KQG/P/ad+3v+I/cbiLoB0/il2kU/fuzcNo7/SeXSg2y+94Cdc9gCa9a5HdaCr0Et0zeQs4xPYEqjg3UhrS7OBTiK/v8bfbi6ZLktHlgKFfjcY+3o50Nuz9B/R3PwapIkXnJaAfu0PnbVfxSYcPlB4n1sAqhME0jIgfWggLQVy5tXpAXbXQGaE/YJIoBSQpoB0OioXSNsEsr/SG5ACILWB/I9xPCKQe6x4QEqgEJDOBdK2gdR9bhWB9A6Bxj96NRwaB7pOg4D6DXlAI5raaP282jaQJoB0/GImkLXqeAz6QNomkCXhA6kNpGsBaWtAkyvqeGA4QBoA0jCQZgLpkYC0BKhnUAykBkgjQNo8kDpAmgIyY+oC6dZA5qZefCsCBtJhH2wg9YG0CpBuB3T9hLT1kXIIpCVA1gMLaBwQAhrPVBsmDFS+36VANxr0QfIRSCsB9YtkchhoDpA5drYB+vH1CoRuRTBA/U6oBWT2bwBTnXzbBVKxV8oHUjVAuiFQ6RFkvrkrkE4Hlex3GVC3z0+auEE8CGTtif1UfSC1l5cDTU6t29BNgfRq9Ol7/FYNF8heshKQtgWUOZ05qawl5qnqFMh7JkVA5rw8PJBWARp/8HbGTYF0dyB437w2AaStHEFiGp6VrgXkPecwkLfVtk6x/vEaQO5GxpMpuKq/1eAcidYEchbNBfLmKgTKeXLxyoBy75sPTr0RUN4TWgco+775yNTunlUEim0y1ipA+Xc9Z23MvZ46Kx4QKP+++ayN3R9Q5SMIrBgHik+6M1D+ffNLN3ZUoOz75qtsLHP9poA2no5ANWYjUMFKBAIrEQisRCCwEoHASo8GVLxJAoFNEghskkBgkwSqtkkC1RpFoFWm32q69SIQiEAgAoF2AzpMOwHlTQqWL1u8dPiy1etMSqBlywlEoGXLCUSgZcsJRKBly+8f6J4iEIhAIAKBCAQiEIhAIAKBCAQiEIhAIAKBCASqD3SR67/cXdbp+tl9M9R/kOgst3/led5wUHWgS3dffemzulxvbjBD/QeJztcb+V/mDkfVBurvCDo9FQ16e+6AzFD/QXKDT7FRs56LW22g/h8/id01Hun85c8PIDPUf5AYa4DmDYdVB/qpO6Jj99tFx3TXIDPUf5AaPZxiM4ejagP1p3zRid+dCR2QGeo/SG+yvxLPHQ5qAKi7e3EB0OnjCPnx9dtRgMoP6+uI+afYeMU5xilWfmE83z6P8jLvKmsOk4NcpGe+tJ5mv8z3Ch+HyUFe5mf+cHaa/4PicA06yA+K11Nm7l81zFD/QWqs3P7DnXnDQfzLKohAIAKBCAQiEIhAIAKBCAQiEIhAIAKBCAQiEIhAIAKBCAQiEIhAIAKBCAQiEIhAIAKBCAQiEIhAIAKBCAQiEIhAoNaBus+HRf8/vC1qHaj7lFjs/6jYpNaB9PL5r18WfgZqUc0D6UmWfchwYe0DXSTyvwJvU/NA76+/Lfsc78KaBzp/+fd1xxex5oG6/5Fq4Wfll9U6UP8J8x0v060D7R6BQAQCEQhEIBCBQAQCEQhEIBCBQAQCEQhEIBCBQAQCEQhEIBCBQAQCEQhEIBCBQAQCEQj0P+vQ+fxh1/DLAAAAAElFTkSuQmCC" /><!-- --></p>
<p>And we calculate the MML, to see whether it is equal to the posterior mean</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nlm</span>(<span class="dt">f =</span> <span class="cf">function</span>(beta){
  <span class="op">-</span><span class="kw">I</span>(beta<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>beta<span class="op">&lt;</span><span class="dv">1</span>)<span class="op">*</span>(<span class="dv">125</span><span class="op">*</span><span class="kw">log</span>(<span class="fl">0.5</span><span class="op">+</span>beta<span class="op">/</span><span class="dv">4</span>)<span class="op">+</span><span class="dv">38</span><span class="op">*</span><span class="kw">log</span>((<span class="dv">1</span><span class="op">-</span>beta)<span class="op">/</span><span class="dv">4</span>)<span class="op">+</span><span class="dv">34</span><span class="op">*</span><span class="kw">log</span>(beta<span class="op">/</span><span class="dv">4</span>))
}, <span class="dt">p =</span> <span class="fl">0.5</span>)<span class="op">$</span>estimate
<span class="co">#&gt; Warning in log((1 - beta)/4): 产生了NaNs</span>
<span class="co">#&gt; Warning in nlm(f = function(beta) {: NA/Inf被换成最大的正值</span>
<span class="co">#&gt; Warning in log((1 - beta)/4): 产生了NaNs</span>
<span class="co">#&gt; Warning in nlm(f = function(beta) {: NA/Inf被换成最大的正值</span>
<span class="co">#&gt; [1] 0.6268209</span>
beta
<span class="co">#&gt; [1] 0.624835</span></code></pre></div>
<p>They are very close, and if the sample number get much lager, they will become closer and closer, since the prior information is becoming less and less significant.</p>
</div>
</div>
<div id="this-is-the-work-in-2018.11.23" class="section level2">
<h2>This is the work in 2018.11.23</h2>
<div id="section-10" class="section level3">
<h3>9.6</h3>
<p>Monitoring convergence</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">N =<span class="st"> </span><span class="dv">2100</span>
K =<span class="st"> </span><span class="dv">50</span>
burnin =<span class="st"> </span><span class="dv">2000</span>
n =<span class="st"> </span>N<span class="op">-</span>burnin
w =<span class="st"> </span><span class="dv">1</span>
x =<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dt">nrow =</span> K, <span class="dt">ncol =</span> N)
x[,<span class="dv">1</span>] =<span class="st"> </span><span class="fl">0.5</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(y) {
  <span class="kw">I</span>(y<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>y<span class="op">&lt;</span><span class="dv">1</span>)<span class="op">*</span>(<span class="fl">0.5</span> <span class="op">+</span><span class="st"> </span>y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">125</span> <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">18</span> <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">20</span> <span class="op">*</span><span class="st"> </span>(y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">34</span>
}
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N) {
  u =<span class="st"> </span><span class="kw">runif</span>(K)
  x1 =<span class="st"> </span><span class="kw">runif</span>(K, <span class="dv">0</span>, w)
  flag =<span class="st"> </span>u<span class="op">&lt;</span><span class="kw">f</span>(x1<span class="op">/</span>x[,(i<span class="op">-</span><span class="dv">1</span>)])
  x[,i] =<span class="st"> </span><span class="kw">I</span>(u<span class="op">&lt;</span><span class="kw">f</span>(x1)<span class="op">/</span><span class="kw">f</span>(x[,(i<span class="op">-</span><span class="dv">1</span>)]))<span class="op">*</span>x1<span class="op">+</span><span class="kw">I</span>(u<span class="op">&gt;=</span><span class="kw">f</span>(x1)<span class="op">/</span><span class="kw">f</span>(x[,(i<span class="op">-</span><span class="dv">1</span>)]))<span class="op">*</span>x[,(i<span class="op">-</span><span class="dv">1</span>)]
}
samp =<span class="st"> </span>x[,(burnin<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>N]
row.mean =<span class="st"> </span><span class="kw">rowMeans</span>(samp)
B_n =<span class="st"> </span><span class="kw">var</span>(row.mean)<span class="op">*</span>n
W_n =<span class="st"> </span><span class="kw">mean</span>((samp<span class="op">-</span>row.mean)<span class="op">^</span><span class="dv">2</span>)
Phi =<span class="st"> </span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>n<span class="op">*</span>W_n<span class="op">+</span><span class="dv">1</span><span class="op">/</span>n<span class="op">*</span>B_n
R =<span class="st"> </span><span class="kw">sqrt</span>(Phi<span class="op">/</span>W_n)
R
<span class="co">#&gt; [1] 1.041413</span></code></pre></div>
<p>I just randomly select some burnin value and N value, and see that after 2000 steps the chain has mixed very well, and converges.</p>
</div>
<div id="section-11" class="section level3">
<h3>11.4</h3>
<p>Find the intersection points A(k) in (0, <span class="math inline">\(\sqrt k\)</span>), of the curves <span class="math inline">\(S_{k-1}(a) = P(t(k-1)&gt;\sqrt{\frac{a^2(k-1)}{k-a^2}})\)</span> and <span class="math inline">\(S_k(a) = P(t(k)&gt;\sqrt{\frac{a^2k}{k+1-a^2}})\)</span> for k = 4:25, 100, 500, 1000, where t(k) is a Student k random variable with k degrees of freedom.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">k =<span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span><span class="op">:</span><span class="dv">25</span>, <span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>)
a =<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(k))
<span class="cf">for</span>(i <span class="cf">in</span> (<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(k))){
  f =<span class="st"> </span><span class="cf">function</span>(a){
    <span class="kw">pt</span>(<span class="kw">sqrt</span>(a<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(k[i]<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>(k[i]<span class="op">-</span>a<span class="op">^</span><span class="dv">2</span>)), <span class="dt">df =</span> k[i]<span class="op">-</span><span class="dv">1</span>, <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>, <span class="dt">log.p =</span> T) <span class="op">/</span><span class="st"> </span><span class="kw">pt</span>(<span class="kw">sqrt</span>(a<span class="op">^</span><span class="dv">2</span><span class="op">*</span>k[i]<span class="op">/</span>(k[i]<span class="op">+</span><span class="dv">1</span><span class="op">-</span>a<span class="op">^</span><span class="dv">2</span>)), <span class="dt">df =</span> k[i], <span class="dt">lower.tail=</span> <span class="ot">FALSE</span>, <span class="dt">log.p =</span> T) <span class="op">-</span><span class="dv">1</span>
  }
  a[i] =<span class="st"> </span><span class="kw">uniroot</span>(f, <span class="kw">c</span>(<span class="fl">0.001</span>, <span class="kw">sqrt</span>(k[i])<span class="op">-</span><span class="fl">0.00001</span>))
}
<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>

<span class="co">#&gt; Warning in a[i] &lt;- uniroot(f, c(0.001, sqrt(k[i]) - 1e-05)): 被替换的项目不</span>
<span class="co">#&gt; 是替换值长度的倍数</span>
<span class="kw">print</span>(a)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1.492099</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 1.533559</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 1.562749</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 1.584401</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; [1] 1.601156</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[6]]</span>
<span class="co">#&gt; [1] 1.614506</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[7]]</span>
<span class="co">#&gt; [1] 1.625382</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[8]]</span>
<span class="co">#&gt; [1] 1.634388</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[9]]</span>
<span class="co">#&gt; [1] 1.642024</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[10]]</span>
<span class="co">#&gt; [1] 1.648521</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[11]]</span>
<span class="co">#&gt; [1] 1.654174</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[12]]</span>
<span class="co">#&gt; [1] 1.659096</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[13]]</span>
<span class="co">#&gt; [1] 1.663434</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[14]]</span>
<span class="co">#&gt; [1] 1.667283</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[15]]</span>
<span class="co">#&gt; [1] 1.670724</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[16]]</span>
<span class="co">#&gt; [1] 1.673811</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[17]]</span>
<span class="co">#&gt; [1] 1.676612</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[18]]</span>
<span class="co">#&gt; [1] 1.679155</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[19]]</span>
<span class="co">#&gt; [1] 1.68148</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[20]]</span>
<span class="co">#&gt; [1] 1.683564</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[21]]</span>
<span class="co">#&gt; [1] 1.685546</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[22]]</span>
<span class="co">#&gt; [1] 1.687346</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[23]]</span>
<span class="co">#&gt; [1] 1.720573</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[24]]</span>
<span class="co">#&gt; [1] 1.729744</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[25]]</span>
<span class="co">#&gt; [1] 1.730889</span></code></pre></div>
<p><em>Analysis</em></p>
<p>At first, if I do not add the log.p = T, when the k gets larger and larger, the result is not correct, especially in the tail of the k, it will approximate the boundary value, which is undesirable compared to the result when the k is smaller. However, if we add log.p = T, the result is much better. So it’s important to add the log.p = T, if we calculate the pt() first, then add log() to it, it is unusable, the problem lies in the accuracy of the calculation. We can run a simple example to show the way the log.p = T works.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">log</span>(<span class="fl">1e-330</span>)
<span class="co">#&gt; [1] -Inf</span>
<span class="kw">log</span>(<span class="fl">1e-115</span>)<span class="op">+</span><span class="kw">log</span>(<span class="fl">1e-115</span>)
<span class="co">#&gt; [1] -529.5946</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="fl">1e-330</span><span class="op">-</span><span class="fl">1e-331</span>
<span class="co">#&gt; [1] 0</span>
<span class="kw">log</span>(<span class="fl">1e-330</span>)<span class="op">-</span><span class="kw">log</span>(<span class="fl">1e-331</span>)
<span class="co">#&gt; [1] NaN</span>
<span class="kw">log</span>(<span class="fl">1e-115</span>)<span class="op">+</span><span class="kw">log</span>(<span class="fl">1e-115</span>)<span class="op">-</span>(<span class="kw">log</span>(<span class="fl">1e-115</span>)<span class="op">+</span><span class="kw">log</span>(<span class="fl">1e-116</span>))
<span class="co">#&gt; [1] 2.302585</span></code></pre></div>
<p>So in the example above, we may see how log.p = T solve the problem.</p>
</div>
</div>
<div id="this-is-the-work-in-2018.11.30" class="section level2">
<h2>This is the work in 2018.11.30</h2>
<div id="a-b-o-blood-type-problem" class="section level3">
<h3>A-B-O blood type problem</h3>
<p>Well this is the work that makes everybody struggle, but I truly learn a lot in this work. At least, I learned how to use the right EM algorithm.</p>
<ul>
<li>Let the three alleles be A, B, and O.</li>
</ul>

<ul>
<li><p>Observed data: <span class="math inline">\(n_{A\cdot}=n_{AA}+n_{AO}=28\)</span> (A-type), <span class="math inline">\(n_{B\cdot}=n_{BB}+n_{BO}=24\)</span> (B-type), <span class="math inline">\(n_{OO}=41\)</span> (O-type), <span class="math inline">\(n_{AB}=70\)</span> (AB-type).</p>
<ul>
<li><p>Use EM algorithm to solve MLE of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> (consider missing data <span class="math inline">\(n_{AA}\)</span> and <span class="math inline">\(n_{BB}\)</span>).</p></li>
<li><p>Record the log-maximum likelihood values in M-steps, are they increasing?</p></li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nA_ =<span class="st"> </span><span class="dv">28</span>; nB_ =<span class="st"> </span><span class="dv">24</span>; nOO =<span class="st"> </span><span class="dv">41</span>;nAB =<span class="st"> </span><span class="dv">70</span>
l =<span class="st"> </span><span class="kw">c</span>(<span class="ot">NULL</span>)

ll =<span class="st"> </span><span class="cf">function</span>(p,q,r){
  <span class="op">-</span>(nA_<span class="op">*</span><span class="kw">log</span>(p<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>p<span class="op">*</span>r)<span class="op">+</span>nB_<span class="op">*</span><span class="kw">log</span>(q<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>q<span class="op">*</span>r)<span class="op">+</span><span class="dv">2</span><span class="op">*</span>nOO<span class="op">*</span><span class="kw">log</span>(r)<span class="op">+</span>nAB<span class="op">*</span><span class="kw">log</span>(<span class="dv">2</span><span class="op">*</span>p<span class="op">*</span>q))
}

pi1 =<span class="st"> </span><span class="fl">0.2</span>
pi2 =<span class="st"> </span><span class="fl">0.2</span>
nAA =<span class="st"> </span>nA_<span class="op">*</span>pi1
nBB =<span class="st"> </span>nB_<span class="op">*</span>pi2
nAO =<span class="st"> </span>nA_<span class="op">-</span>nAA
nBO =<span class="st"> </span>nB_<span class="op">-</span>nBB
p =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>nAA<span class="op">+</span>nAO<span class="op">+</span>nAB
q =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>nBB<span class="op">+</span>nBO<span class="op">+</span>nAB
r =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>nOO<span class="op">+</span>nAO<span class="op">+</span>nBO
sum =<span class="st"> </span>p<span class="op">+</span>q<span class="op">+</span>r
p =<span class="st"> </span>p<span class="op">/</span>sum
q =<span class="st"> </span>q<span class="op">/</span>sum
r =<span class="st"> </span>r<span class="op">/</span>sum

<span class="kw">print</span>(<span class="kw">c</span>(p,q,r))
<span class="co">#&gt; [1] 0.3177914 0.3030675 0.3791411</span>

l =<span class="st"> </span><span class="kw">c</span>(l, <span class="kw">ll</span>(p,q,r))


EM =<span class="st"> </span><span class="cf">function</span>(<span class="dt">tol =</span> <span class="fl">1e-12</span>){
  iter =<span class="st"> </span><span class="dv">1</span>
  flag =<span class="st"> </span><span class="ot">TRUE</span>
  <span class="cf">while</span>(flag <span class="op">==</span><span class="st"> </span><span class="ot">TRUE</span>){
    pi1 =<span class="st"> </span>p<span class="op">/</span>(p<span class="op">+</span><span class="dv">2</span><span class="op">*</span>r)
    pi2 =<span class="st"> </span>q<span class="op">/</span>(q<span class="op">+</span><span class="dv">2</span><span class="op">*</span>r)
    nAA =<span class="st"> </span>nA_<span class="op">*</span>pi1
    nBB =<span class="st"> </span>nB_<span class="op">*</span>pi2
    nAO =<span class="st"> </span>nA_<span class="op">-</span>nAA
    nBO =<span class="st"> </span>nB_<span class="op">-</span>nBB
    p.new =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>nAA<span class="op">+</span>nAO<span class="op">+</span>nAB
    q.new =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>nBB<span class="op">+</span>nBO<span class="op">+</span>nAB
    r.new =<span class="st"> </span><span class="dv">2</span><span class="op">*</span>nOO<span class="op">+</span>nAO<span class="op">+</span>nBO
    sum =<span class="st"> </span>p.new<span class="op">+</span>q.new<span class="op">+</span>r.new
    p.new =<span class="st"> </span>p.new<span class="op">/</span>sum
    q.new =<span class="st"> </span>q.new<span class="op">/</span>sum
    r.new =<span class="st"> </span>r.new<span class="op">/</span>sum
    flag =<span class="st"> </span><span class="kw">max</span>(<span class="kw">abs</span>(p.new<span class="op">-</span>p), <span class="kw">abs</span>(q.new<span class="op">-</span>q), <span class="kw">abs</span>(r.new<span class="op">-</span>r))<span class="op">&gt;</span>tol
    iter =<span class="st"> </span>iter<span class="op">+</span><span class="dv">1</span>
    p =<span class="st"> </span>p.new
    q =<span class="st"> </span>q.new
    r =<span class="st"> </span>r.new
    l =<span class="st"> </span><span class="kw">c</span>(l, <span class="kw">ll</span>(p,q,r))
  }
  <span class="kw">list</span>(<span class="dt">p =</span> p, <span class="dt">q =</span> q, <span class="dt">r =</span> r, <span class="dt">iter =</span> iter, <span class="dt">ll =</span> l)
}

result =<span class="st"> </span><span class="kw">EM</span>()

result
<span class="co">#&gt; $p</span>
<span class="co">#&gt; [1] 0.3273442</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $q</span>
<span class="co">#&gt; [1] 0.3104267</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $r</span>
<span class="co">#&gt; [1] 0.3622291</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $iter</span>
<span class="co">#&gt; [1] 15</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $ll</span>
<span class="co">#&gt;  [1] 252.0857 251.9181 251.9146 251.9145 251.9145 251.9145 251.9145</span>
<span class="co">#&gt;  [8] 251.9145 251.9145 251.9145 251.9145 251.9145 251.9145 251.9145</span>
<span class="co">#&gt; [15] 251.9145</span>

<span class="kw">plot</span>(result<span class="op">$</span>ll)</code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p><em>Analysis</em></p>
<p>I’ll share my idea. We can see that if we know all the nAA, nBB or things like that, we can easily derive the loglikehood, and we can easily solve this problem, but here we are only provided things like nA_, nB_, so the hidden variable is nAA and nBB or we can say is the probability of nAA in nA_ and probability of nBB in bB_ and I use thses as hidden variables. The things I describe above is the E step, and next I will describe M step. When we estimated the pi1 and pi2, we can use this to get nAA and nBB, so we can get the full likelihood function, and then we can get the estimation of p,q,r using MLL method. And finnaly I use the change of parameter between two steps as our stop criteria.</p>
<p>We can also use the change between the negative log likelihood as my criteria, which is more rigorous.</p>
<p>And since there is a theoretical guarantee of EM method which guarantee the decrease of negative log likelihood, and through our simulation, we can prove this.</p>
<p>Compare our result with the maximum likelihood.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nlm</span>(<span class="dt">f =</span> <span class="cf">function</span>(beta){
  p =<span class="st"> </span>beta[<span class="dv">1</span>]; q =<span class="st"> </span>beta[<span class="dv">2</span>]; r =<span class="st"> </span><span class="dv">1</span><span class="op">-</span>p<span class="op">-</span>q
  <span class="op">-</span>(nA_<span class="op">*</span><span class="kw">log</span>(p<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>p<span class="op">*</span>r)<span class="op">+</span>nB_<span class="op">*</span><span class="kw">log</span>(q<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>q<span class="op">*</span>r)<span class="op">+</span><span class="dv">2</span><span class="op">*</span>nOO<span class="op">*</span><span class="kw">log</span>(r)<span class="op">+</span>nAB<span class="op">*</span><span class="kw">log</span>(<span class="dv">2</span><span class="op">*</span>p<span class="op">*</span>q))
}, <span class="dt">p =</span> <span class="kw">c</span>(<span class="fl">0.4</span>,<span class="fl">0.3</span>))
<span class="co">#&gt; Warning in log(p^2 + 2 * p * r): 产生了NaNs</span>
<span class="co">#&gt; Warning in log(q^2 + 2 * q * r): 产生了NaNs</span>
<span class="co">#&gt; Warning in nlm(f = function(beta) {: NA/Inf被换成最大的正值</span>
<span class="co">#&gt; Warning in log(p^2 + 2 * p * r): 产生了NaNs</span>
<span class="co">#&gt; Warning in log(q^2 + 2 * q * r): 产生了NaNs</span>
<span class="co">#&gt; Warning in nlm(f = function(beta) {: NA/Inf被换成最大的正值</span>
<span class="co">#&gt; Warning in log(p^2 + 2 * p * r): 产生了NaNs</span>
<span class="co">#&gt; Warning in log(q^2 + 2 * q * r): 产生了NaNs</span>
<span class="co">#&gt; Warning in nlm(f = function(beta) {: NA/Inf被换成最大的正值</span>
<span class="co">#&gt; $minimum</span>
<span class="co">#&gt; [1] 251.9145</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $estimate</span>
<span class="co">#&gt; [1] 0.3273438 0.3104263</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $gradient</span>
<span class="co">#&gt; [1] -0.0001217586 -0.0001165290</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $code</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $iterations</span>
<span class="co">#&gt; [1] 5</span></code></pre></div>
<p>They are almost the same, so I can conclude that my EM method converges to the true parameter.</p>
</div>
<div id="section-12" class="section level3">
<h3>11.6</h3>
<p>Write a function to compute the cdf of the Cauchy distribution, which has density</p>
<p>where??&gt;0. Compare your results to the results from the R function pcauchy. (Also see the source code in pcauchy.c.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">eta =<span class="st"> </span><span class="dv">0</span>
theta =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dt">length.out =</span> <span class="dv">10</span>)
n =<span class="st"> </span><span class="dv">100</span>
f =<span class="st"> </span><span class="cf">function</span>(x, eta, theta){
  <span class="dv">1</span><span class="op">/</span>(theta<span class="op">*</span>pi<span class="op">*</span>(<span class="dv">1</span><span class="op">+</span>((x<span class="op">-</span>eta)<span class="op">/</span>theta)<span class="op">^</span><span class="dv">2</span>))
}
v =<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="kw">length</span>(theta), n)
q =<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">20</span>, <span class="dv">20</span>, <span class="dt">length.out =</span> n)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(theta)) {
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
    v[i, j] =<span class="st"> </span><span class="kw">integrate</span>(f, <span class="dt">lower =</span> <span class="op">-</span><span class="ot">Inf</span>, <span class="dt">upper =</span> q[j], <span class="dt">theta =</span> theta[i], eta)<span class="op">$</span>value
  }
}
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">5</span>))
g =<span class="st"> </span><span class="cf">function</span>(x) {x}
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(theta)) {
  qc =<span class="st"> </span><span class="kw">pcauchy</span>(q, <span class="dt">scale =</span> theta[i])
  <span class="kw">qqplot</span>(qc, v[i, ], <span class="dt">xlab =</span> <span class="st">&quot;Cauchy Quantiles&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Integration Quantiles&quot;</span>)
  <span class="kw">curve</span>(g, <span class="dt">add =</span> T, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)
}</code></pre></div>
<p>In building pdf, this chunck suffers from a problem and I don’t know why, so I don’t evaluate it.</p>
<p>We can see that our numerical integration do get the right calculation.</p>
</div>
</div>
<div id="this-is-the-work-in-2018.12.7" class="section level2">
<h2>This is the work in 2018.12.7</h2>
<div id="p204-3" class="section level3">
<h3>p204 3</h3>
<p>Use both for loops and lapply() to fit linear models to the mtcars using the formulas stored in this list: formulas&lt;-list( mpg ~ disp, mpg ~ I(1/disp), mpg ~ disp+wt, mpg ~ I(1/disp)+wt )</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(mtcars)
formulas&lt;-<span class="kw">list</span>(
  mpg <span class="op">~</span><span class="st"> </span>disp,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span><span class="op">/</span>disp),
  mpg <span class="op">~</span><span class="st"> </span>disp<span class="op">+</span>wt,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span><span class="op">/</span>disp)<span class="op">+</span>wt
)
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))

models1 =<span class="st"> </span><span class="kw">lapply</span>(formulas, lm)
<span class="kw">print</span>(models1)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; FUN(formula = X[[i]])</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    29.59985     -0.04122  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; FUN(formula = X[[i]])</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)    I(1/disp)  </span>
<span class="co">#&gt;       10.75      1557.67  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; FUN(formula = X[[i]])</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp           wt  </span>
<span class="co">#&gt;    34.96055     -0.01772     -3.35083  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; FUN(formula = X[[i]])</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)    I(1/disp)           wt  </span>
<span class="co">#&gt;      19.024     1142.560       -1.798</span>

<span class="cf">for</span>(item <span class="cf">in</span> formulas)
  <span class="kw">print</span>(<span class="kw">lm</span>(item))
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = item)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    29.59985     -0.04122  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = item)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)    I(1/disp)  </span>
<span class="co">#&gt;       10.75      1557.67  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = item)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp           wt  </span>
<span class="co">#&gt;    34.96055     -0.01772     -3.35083  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = item)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)    I(1/disp)           wt  </span>
<span class="co">#&gt;      19.024     1142.560       -1.798</span></code></pre></div>
<p>We can easily see they give the same result and the first solution is quicker to code.</p>
</div>
<div id="p204-4" class="section level3">
<h3>p204 4</h3>
<p>Fit the model mpg ~ disp to each of the bootstrap replicates of mtcars in the list below by using a for loop and lapply(). Can you do it without an anonymous function?</p>
<p>bootstraps &lt;- lapply(1:10, function(i) { rows &lt;- sample(1:nrow(mtcars), rep = TRUE) mtcars[rows, ] })</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bootstraps &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="cf">function</span>(i) {   rows &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(mtcars), <span class="dt">rep =</span> <span class="ot">TRUE</span>)
  mtcars[rows, ]
}) 

<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>){
  mpg =<span class="st"> </span>bootstraps[[i]]<span class="op">$</span>mpg
  disp =<span class="st"> </span>bootstraps[[i]]<span class="op">$</span>disp
  <span class="kw">print</span>(<span class="kw">lm</span>(mpg<span class="op">~</span>disp))
}
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    32.54208     -0.04905  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    27.08179     -0.03348  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    28.58622     -0.03854  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    28.90171     -0.03598  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    27.78680     -0.03811  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    30.41928     -0.04375  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    29.43143     -0.03805  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    27.92144     -0.03503  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    27.63509     -0.03391  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;    29.30172     -0.03902</span>

models2 =<span class="st"> </span><span class="kw">lapply</span>(bootstraps, <span class="cf">function</span>(o){
  <span class="kw">lm</span>(o<span class="op">$</span>mpg<span class="op">~</span>o<span class="op">$</span>disp)})
<span class="kw">print</span>(models2)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    32.54208     -0.04905  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    27.08179     -0.03348  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    28.58622     -0.03854  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    28.90171     -0.03598  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    27.78680     -0.03811  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[6]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    30.41928     -0.04375  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[7]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    29.43143     -0.03805  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[8]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    27.92144     -0.03503  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[9]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    27.63509     -0.03391  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[10]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = o$mpg ~ o$disp)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)       o$disp  </span>
<span class="co">#&gt;    29.30172     -0.03902</span></code></pre></div>
<p>We can see they give the same result.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">replicate</span>(<span class="dv">10</span>, <span class="dt">expr =</span> {
  rows &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(mtcars), <span class="dt">rep =</span> <span class="ot">TRUE</span>)
  a =<span class="st"> </span>mtcars[rows, ]
  mpg =<span class="st"> </span>a<span class="op">$</span>mpg
  disp =<span class="st"> </span>a<span class="op">$</span>disp
  <span class="kw">lm</span>(mpg<span class="op">~</span>disp)
})
<span class="co">#&gt;               [,1]       [,2]       [,3]       [,4]       [,5]      </span>
<span class="co">#&gt; coefficients  Numeric,2  Numeric,2  Numeric,2  Numeric,2  Numeric,2 </span>
<span class="co">#&gt; residuals     Numeric,32 Numeric,32 Numeric,32 Numeric,32 Numeric,32</span>
<span class="co">#&gt; effects       Numeric,32 Numeric,32 Numeric,32 Numeric,32 Numeric,32</span>
<span class="co">#&gt; rank          2          2          2          2          2         </span>
<span class="co">#&gt; fitted.values Numeric,32 Numeric,32 Numeric,32 Numeric,32 Numeric,32</span>
<span class="co">#&gt; assign        Integer,2  Integer,2  Integer,2  Integer,2  Integer,2 </span>
<span class="co">#&gt; qr            List,5     List,5     List,5     List,5     List,5    </span>
<span class="co">#&gt; df.residual   30         30         30         30         30        </span>
<span class="co">#&gt; xlevels       List,0     List,0     List,0     List,0     List,0    </span>
<span class="co">#&gt; call          Expression Expression Expression Expression Expression</span>
<span class="co">#&gt; terms         Expression Expression Expression Expression Expression</span>
<span class="co">#&gt; model         List,2     List,2     List,2     List,2     List,2    </span>
<span class="co">#&gt;               [,6]       [,7]       [,8]       [,9]       [,10]     </span>
<span class="co">#&gt; coefficients  Numeric,2  Numeric,2  Numeric,2  Numeric,2  Numeric,2 </span>
<span class="co">#&gt; residuals     Numeric,32 Numeric,32 Numeric,32 Numeric,32 Numeric,32</span>
<span class="co">#&gt; effects       Numeric,32 Numeric,32 Numeric,32 Numeric,32 Numeric,32</span>
<span class="co">#&gt; rank          2          2          2          2          2         </span>
<span class="co">#&gt; fitted.values Numeric,32 Numeric,32 Numeric,32 Numeric,32 Numeric,32</span>
<span class="co">#&gt; assign        Integer,2  Integer,2  Integer,2  Integer,2  Integer,2 </span>
<span class="co">#&gt; qr            List,5     List,5     List,5     List,5     List,5    </span>
<span class="co">#&gt; df.residual   30         30         30         30         30        </span>
<span class="co">#&gt; xlevels       List,0     List,0     List,0     List,0     List,0    </span>
<span class="co">#&gt; call          Expression Expression Expression Expression Expression</span>
<span class="co">#&gt; terms         Expression Expression Expression Expression Expression</span>
<span class="co">#&gt; model         List,2     List,2     List,2     List,2     List,2</span></code></pre></div>
<p>We can use replicate to get the same result.</p>
</div>
<div id="p204-5" class="section level3">
<h3>p204 5</h3>
<p>For each model in the previous two exercises,extract R2 using the function below. rsq &lt;- function(mod) summary(mod)$r.squared</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rsq &lt;-<span class="st"> </span><span class="cf">function</span>(mod) <span class="kw">summary</span>(mod)<span class="op">$</span>r.squared
<span class="kw">lapply</span>(models1, rsq)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 0.7183433</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 0.8596865</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 0.7809306</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 0.8838038</span>
<span class="kw">lapply</span>(models2, rsq)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 0.8280449</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 0.677841</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 0.5877843</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 0.7191786</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; [1] 0.6778923</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[6]]</span>
<span class="co">#&gt; [1] 0.7766273</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[7]]</span>
<span class="co">#&gt; [1] 0.7581888</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[8]]</span>
<span class="co">#&gt; [1] 0.6865405</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[9]]</span>
<span class="co">#&gt; [1] 0.6343591</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[10]]</span>
<span class="co">#&gt; [1] 0.7130955</span></code></pre></div>
<p>Use lapply we can easily get the result.</p>
</div>
<div id="p213-3" class="section level3">
<h3>p213 3</h3>
<p>The following code simulates the performance of a t-test for non-normal data. Use sapply() and an anonymous function to extract the p-value from every trial. trials &lt;- replicate( 100, t.test(rpois(10, 10), rpois(7, 10)), simplify = FALSE )</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trials &lt;-<span class="st"> </span><span class="kw">replicate</span>(
  <span class="dv">100</span>,
  <span class="kw">t.test</span>(<span class="kw">rpois</span>(<span class="dv">10</span>, <span class="dv">10</span>), <span class="kw">rpois</span>(<span class="dv">7</span>, <span class="dv">10</span>)),
  <span class="dt">simplify =</span> <span class="ot">FALSE</span>
)
<span class="kw">sapply</span>(trials, <span class="cf">function</span>(o) o<span class="op">$</span>p.value)
<span class="co">#&gt;   [1] 0.14446012 0.15957953 0.47668247 0.66204724 0.23355289 0.71431037</span>
<span class="co">#&gt;   [7] 0.73347244 0.97109648 0.46925275 0.52225488 0.59325068 0.81689166</span>
<span class="co">#&gt;  [13] 0.16618819 0.50370888 0.78990178 0.53803119 0.21090668 0.23047731</span>
<span class="co">#&gt;  [19] 0.59021624 0.84023813 0.78164211 0.39455143 0.73253337 0.69661212</span>
<span class="co">#&gt;  [25] 0.25654806 0.57681425 0.71119716 0.49919053 0.53290316 0.29763688</span>
<span class="co">#&gt;  [31] 0.34226829 0.34962789 0.28696774 0.49362260 0.40906293 0.09699549</span>
<span class="co">#&gt;  [37] 0.66770143 0.96689885 0.65838013 0.75177423 0.12064955 0.37653976</span>
<span class="co">#&gt;  [43] 0.44702023 0.33643316 0.65108604 0.28847227 0.25366279 0.27737269</span>
<span class="co">#&gt;  [49] 0.38555625 0.85151916 0.93563310 0.66081089 0.58325341 0.16432005</span>
<span class="co">#&gt;  [55] 0.15295825 0.95615304 0.96174420 0.10953659 0.07879758 0.11495792</span>
<span class="co">#&gt;  [61] 0.77071529 0.95963392 0.28988853 0.54656594 0.77901072 0.52211559</span>
<span class="co">#&gt;  [67] 0.31628364 0.22192399 0.37667936 0.74645297 0.07292435 0.49570351</span>
<span class="co">#&gt;  [73] 0.38532705 0.17255760 0.82063671 0.05304169 0.90218924 0.03486619</span>
<span class="co">#&gt;  [79] 0.11899587 0.50095539 0.60216725 0.64543586 0.28215849 0.54901255</span>
<span class="co">#&gt;  [85] 1.00000000 0.19880220 0.18858016 0.71902984 0.74712408 0.61385487</span>
<span class="co">#&gt;  [91] 0.16258326 0.96414285 0.13777126 0.79367871 0.22164791 0.58460492</span>
<span class="co">#&gt;  [97] 0.31018706 0.22803970 0.62159777 0.25966861</span></code></pre></div>
<p>Use sapply we can easily get the result.</p>
<p>Extra challenge:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">100</span>)
  <span class="kw">print</span>(trials[[i]]<span class="op">$</span>p.value)
<span class="co">#&gt; [1] 0.1444601</span>
<span class="co">#&gt; [1] 0.1595795</span>
<span class="co">#&gt; [1] 0.4766825</span>
<span class="co">#&gt; [1] 0.6620472</span>
<span class="co">#&gt; [1] 0.2335529</span>
<span class="co">#&gt; [1] 0.7143104</span>
<span class="co">#&gt; [1] 0.7334724</span>
<span class="co">#&gt; [1] 0.9710965</span>
<span class="co">#&gt; [1] 0.4692527</span>
<span class="co">#&gt; [1] 0.5222549</span>
<span class="co">#&gt; [1] 0.5932507</span>
<span class="co">#&gt; [1] 0.8168917</span>
<span class="co">#&gt; [1] 0.1661882</span>
<span class="co">#&gt; [1] 0.5037089</span>
<span class="co">#&gt; [1] 0.7899018</span>
<span class="co">#&gt; [1] 0.5380312</span>
<span class="co">#&gt; [1] 0.2109067</span>
<span class="co">#&gt; [1] 0.2304773</span>
<span class="co">#&gt; [1] 0.5902162</span>
<span class="co">#&gt; [1] 0.8402381</span>
<span class="co">#&gt; [1] 0.7816421</span>
<span class="co">#&gt; [1] 0.3945514</span>
<span class="co">#&gt; [1] 0.7325334</span>
<span class="co">#&gt; [1] 0.6966121</span>
<span class="co">#&gt; [1] 0.2565481</span>
<span class="co">#&gt; [1] 0.5768143</span>
<span class="co">#&gt; [1] 0.7111972</span>
<span class="co">#&gt; [1] 0.4991905</span>
<span class="co">#&gt; [1] 0.5329032</span>
<span class="co">#&gt; [1] 0.2976369</span>
<span class="co">#&gt; [1] 0.3422683</span>
<span class="co">#&gt; [1] 0.3496279</span>
<span class="co">#&gt; [1] 0.2869677</span>
<span class="co">#&gt; [1] 0.4936226</span>
<span class="co">#&gt; [1] 0.4090629</span>
<span class="co">#&gt; [1] 0.09699549</span>
<span class="co">#&gt; [1] 0.6677014</span>
<span class="co">#&gt; [1] 0.9668989</span>
<span class="co">#&gt; [1] 0.6583801</span>
<span class="co">#&gt; [1] 0.7517742</span>
<span class="co">#&gt; [1] 0.1206496</span>
<span class="co">#&gt; [1] 0.3765398</span>
<span class="co">#&gt; [1] 0.4470202</span>
<span class="co">#&gt; [1] 0.3364332</span>
<span class="co">#&gt; [1] 0.651086</span>
<span class="co">#&gt; [1] 0.2884723</span>
<span class="co">#&gt; [1] 0.2536628</span>
<span class="co">#&gt; [1] 0.2773727</span>
<span class="co">#&gt; [1] 0.3855562</span>
<span class="co">#&gt; [1] 0.8515192</span>
<span class="co">#&gt; [1] 0.9356331</span>
<span class="co">#&gt; [1] 0.6608109</span>
<span class="co">#&gt; [1] 0.5832534</span>
<span class="co">#&gt; [1] 0.16432</span>
<span class="co">#&gt; [1] 0.1529583</span>
<span class="co">#&gt; [1] 0.956153</span>
<span class="co">#&gt; [1] 0.9617442</span>
<span class="co">#&gt; [1] 0.1095366</span>
<span class="co">#&gt; [1] 0.07879758</span>
<span class="co">#&gt; [1] 0.1149579</span>
<span class="co">#&gt; [1] 0.7707153</span>
<span class="co">#&gt; [1] 0.9596339</span>
<span class="co">#&gt; [1] 0.2898885</span>
<span class="co">#&gt; [1] 0.5465659</span>
<span class="co">#&gt; [1] 0.7790107</span>
<span class="co">#&gt; [1] 0.5221156</span>
<span class="co">#&gt; [1] 0.3162836</span>
<span class="co">#&gt; [1] 0.221924</span>
<span class="co">#&gt; [1] 0.3766794</span>
<span class="co">#&gt; [1] 0.746453</span>
<span class="co">#&gt; [1] 0.07292435</span>
<span class="co">#&gt; [1] 0.4957035</span>
<span class="co">#&gt; [1] 0.3853271</span>
<span class="co">#&gt; [1] 0.1725576</span>
<span class="co">#&gt; [1] 0.8206367</span>
<span class="co">#&gt; [1] 0.05304169</span>
<span class="co">#&gt; [1] 0.9021892</span>
<span class="co">#&gt; [1] 0.03486619</span>
<span class="co">#&gt; [1] 0.1189959</span>
<span class="co">#&gt; [1] 0.5009554</span>
<span class="co">#&gt; [1] 0.6021673</span>
<span class="co">#&gt; [1] 0.6454359</span>
<span class="co">#&gt; [1] 0.2821585</span>
<span class="co">#&gt; [1] 0.5490126</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; [1] 0.1988022</span>
<span class="co">#&gt; [1] 0.1885802</span>
<span class="co">#&gt; [1] 0.7190298</span>
<span class="co">#&gt; [1] 0.7471241</span>
<span class="co">#&gt; [1] 0.6138549</span>
<span class="co">#&gt; [1] 0.1625833</span>
<span class="co">#&gt; [1] 0.9641429</span>
<span class="co">#&gt; [1] 0.1377713</span>
<span class="co">#&gt; [1] 0.7936787</span>
<span class="co">#&gt; [1] 0.2216479</span>
<span class="co">#&gt; [1] 0.5846049</span>
<span class="co">#&gt; [1] 0.3101871</span>
<span class="co">#&gt; [1] 0.2280397</span>
<span class="co">#&gt; [1] 0.6215978</span>
<span class="co">#&gt; [1] 0.2596686</span></code></pre></div>
</div>
<div id="p214-6" class="section level3">
<h3>p214 6</h3>
<p>Implement a combination of Map() and vapply() to create an lapply() variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(parallel)
mcvMap &lt;-<span class="st"> </span><span class="cf">function</span>(f, FUN.VALUE , ...) {
    out &lt;-<span class="st"> </span><span class="kw">mcMap</span>(f, ...)
    <span class="kw">vapply</span>(out, identity, FUN.VALUE)
}</code></pre></div>
<p>If your computer is windows, you should use foreach library</p>
</div>
</div>
<div id="this-is-the-work-in-2018.12.14" class="section level2">
<h2>This is the work in 2018.12.14</h2>
<div id="p365-4" class="section level3">
<h3>p365 4</h3>
<p>Make a faster version of chsiq.test() that only computes the chi-sqaure statistic when the input is two numeric vectors with no missing values. You can try simplifying chisq.test() or by coding from the mathematical de???nition.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chisq.test1 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y){
  m =<span class="st"> </span><span class="kw">table</span>(x, y)
  margin1 &lt;-<span class="st"> </span><span class="kw">rowSums</span>(m)
  margin2 &lt;-<span class="st"> </span><span class="kw">colSums</span>(m)
  n &lt;-<span class="st"> </span><span class="kw">sum</span>(m)
  me &lt;-<span class="st"> </span><span class="kw">tcrossprod</span>(margin1, margin2) <span class="op">/</span><span class="st"> </span>n
  x_stat =<span class="st"> </span><span class="kw">sum</span>((m <span class="op">-</span><span class="st"> </span>me)<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>me)
  x_stat
}</code></pre></div>
<p>We can first check our implementation gives the right answer.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>, <span class="dt">size =</span> <span class="dv">50</span>)
y =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>, <span class="dt">size =</span> <span class="dv">50</span>)
<span class="kw">chisq.test1</span>(x, y)
<span class="co">#&gt; [1] 2.360491</span>
<span class="kw">chisq.test</span>(x,y)
<span class="co">#&gt; Warning in chisq.test(x, y): Chi-squared approximation may be incorrect</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;  Pearson's Chi-squared test</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; data:  x and y</span>
<span class="co">#&gt; X-squared = 2.3605, df = 4, p-value = 0.6698</span></code></pre></div>
<p>And We can also Finally we can use microbenchmark to compare this implementation against the original</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
<span class="co">#&gt; Warning: 程辑包'microbenchmark'是用R版本3.4.4 来建造的</span>
<span class="kw">microbenchmark</span>(
  <span class="kw">suppressWarnings</span>(<span class="kw">chisq.test</span>(x,y)),
  <span class="kw">chisq.test1</span>(x,y)
)
<span class="co">#&gt; Unit: microseconds</span>
<span class="co">#&gt;                                expr     min       lq     mean   median</span>
<span class="co">#&gt;  suppressWarnings(chisq.test(x, y)) 731.734 765.4405 877.8542 837.1200</span>
<span class="co">#&gt;                   chisq.test1(x, y) 253.014 270.7205 431.5952 299.0945</span>
<span class="co">#&gt;        uq      max neval</span>
<span class="co">#&gt;  912.4275 1502.294   100</span>
<span class="co">#&gt;  358.4005 9798.396   100</span></code></pre></div>
<p>We can find that my method is much quicker.</p>
<p><em>One thing to Note</em></p>
<p>And we should use suppressWarnings() to compare the speed,otherwise, the warnings to slow down the chisq.test(), so we cannot get the right speed.</p>
</div>
<div id="p365-5" class="section level3">
<h3>p365 5</h3>
<p>Can you make a faster version of table() for the case of an input of two integer vectors with no missing values? Can you use it to speed up your chi-square test?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table1 =<span class="st"> </span><span class="cf">function</span>(x,y){
  rowname =<span class="st"> </span><span class="kw">unique</span>(x)
  colname =<span class="st"> </span><span class="kw">unique</span>(y)
  a =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="kw">length</span>(rowname), <span class="kw">length</span>(colname), <span class="dt">dimnames =</span> <span class="kw">list</span>(rowname, colname))
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(x)){
    m =<span class="st"> </span><span class="kw">which</span>(rowname <span class="op">==</span><span class="st"> </span>x[i])
    n =<span class="st"> </span><span class="kw">which</span>(colname <span class="op">==</span><span class="st"> </span>y[i])
    a[m,n] =<span class="st"> </span>a[m,n]<span class="op">+</span><span class="dv">1</span>
  }
  
  <span class="kw">class</span>(a) =<span class="st"> 'table'</span>
  a
}</code></pre></div>
<p>First, test the correctness</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
b =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)
<span class="kw">table</span>(a,b)
<span class="co">#&gt;    b</span>
<span class="co">#&gt; a   1 2 3 4 5</span>
<span class="co">#&gt;   1 0 0 1 0 0</span>
<span class="co">#&gt;   2 0 1 0 0 0</span>
<span class="co">#&gt;   3 0 0 0 1 0</span>
<span class="co">#&gt;   4 1 0 0 0 0</span>
<span class="co">#&gt;   5 0 0 0 0 1</span>
<span class="kw">table1</span>(a,b)
<span class="co">#&gt;   3 2 4 1 5</span>
<span class="co">#&gt; 1 1 0 0 0 0</span>
<span class="co">#&gt; 2 0 1 0 0 0</span>
<span class="co">#&gt; 3 0 0 1 0 0</span>
<span class="co">#&gt; 4 0 0 0 1 0</span>
<span class="co">#&gt; 5 0 0 0 0 1</span></code></pre></div>
<p>We can find that they are the same</p>
<p>Then test for the speed</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
<span class="kw">microbenchmark</span>(
  <span class="kw">table</span>(x,y),
  <span class="kw">table1</span>(x,y)
)
<span class="co">#&gt; Unit: microseconds</span>
<span class="co">#&gt;          expr     min       lq     mean   median       uq     max neval</span>
<span class="co">#&gt;   table(x, y) 198.827 210.1335 249.3658 225.4935 249.3875 793.600   100</span>
<span class="co">#&gt;  table1(x, y) 137.814 145.9200 167.2368 150.1875 161.4940 407.894   100</span></code></pre></div>
<p>My method is quicker.</p>
<p>However, there is still ways to improve my method, such as use Rcpp to do the loop, this will definitely increase the speed. But here we will omit it, since our method is better than the original.</p>
<p>Use table1 to make my chisq.test faster.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chisq.test2 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y){
  m =<span class="st"> </span><span class="kw">table1</span>(x, y)
  margin1 &lt;-<span class="st"> </span><span class="kw">rowSums</span>(m)
  margin2 &lt;-<span class="st"> </span><span class="kw">colSums</span>(m)
  n &lt;-<span class="st"> </span><span class="kw">sum</span>(m)
  me &lt;-<span class="st"> </span><span class="kw">tcrossprod</span>(margin1, margin2) <span class="op">/</span><span class="st"> </span>n
  x_stat =<span class="st"> </span><span class="kw">sum</span>((m <span class="op">-</span><span class="st"> </span>me)<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>me)
  x_stat
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">microbenchmark</span>(
  <span class="kw">suppressWarnings</span>(<span class="kw">chisq.test</span>(x,y)),
  <span class="kw">chisq.test1</span>(x,y),
  <span class="kw">chisq.test2</span>(x,y)
)
<span class="co">#&gt; Unit: microseconds</span>
<span class="co">#&gt;                                expr     min       lq     mean   median</span>
<span class="co">#&gt;  suppressWarnings(chisq.test(x, y)) 730.027 762.4535 860.0579 825.3865</span>
<span class="co">#&gt;                   chisq.test1(x, y) 250.881 275.4140 311.5355 294.8275</span>
<span class="co">#&gt;                   chisq.test2(x, y) 171.520 185.8140 287.8299 198.1870</span>
<span class="co">#&gt;        uq      max neval</span>
<span class="co">#&gt;  907.5205 1436.587   100</span>
<span class="co">#&gt;  311.2535  571.307   100</span>
<span class="co">#&gt;  218.2405 7952.211   100</span></code></pre></div>
<p>We can see through the new version of table1() our method is quicker.</p>
</div>
<div id="additional" class="section level3">
<h3>Additional</h3>
<p>Write an Rcpp function for Exercise 9.6 (page 277, Statistical Computing with R). Compare the corresponding generated random numbers with those by the R function you wrote before using the function “qqplot”. Campare the computation time of the two functions with the function “microbenchmark”. Comments your results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">N =<span class="st"> </span><span class="dv">10000</span>
burnin =<span class="st"> </span><span class="dv">2000</span>
RMCMC =<span class="st"> </span><span class="cf">function</span>(N){
  x =<span class="st"> </span><span class="kw">numeric</span>(N)
  x[<span class="dv">1</span>] =<span class="st"> </span><span class="fl">0.5</span>
  f &lt;-<span class="st"> </span><span class="cf">function</span>(y) {
    <span class="kw">I</span>(y<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>y<span class="op">&lt;</span><span class="dv">1</span>)<span class="op">*</span>(<span class="fl">0.5</span> <span class="op">+</span><span class="st"> </span>y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">125</span> <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">18</span> <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">20</span> <span class="op">*</span><span class="st"> </span>(y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span><span class="dv">34</span>
  }
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N) {
    k =<span class="st"> </span><span class="dv">0</span>
    u =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
    x1 =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
    <span class="cf">if</span>(u <span class="op">&lt;</span><span class="st"> </span><span class="kw">f</span>(x1)<span class="op">/</span><span class="kw">f</span>(x[i<span class="op">-</span><span class="dv">1</span>])){
      x[i] =<span class="st"> </span>x1
      k =<span class="st"> </span>k<span class="op">+</span><span class="dv">1</span>
    }
    <span class="cf">else</span> x[i] =<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
  }
  x
}
x =<span class="st"> </span><span class="kw">RMCMC</span>(N)
xp =<span class="st"> </span>x[(burnin<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>N]
<span class="kw">hist</span>(xp)</code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAulBMVEUAAAAAADoAAGYAOjoAOmYAOpAAZpAAZrY6AAA6ADo6OgA6Ojo6OmY6OpA6ZpA6ZrY6kLY6kNtmAABmADpmOgBmOjpmZmZmkJBmkLZmkNtmtttmtv+QOgCQZgCQZjqQkGaQkLaQtpCQttuQtv+Q2/+2ZgC2Zjq2ZpC2kGa227a229u22/+2/7a2/9u2///bkDrbkGbbtmbbtpDb27bb29vb/7bb/9vb////tmb/25D/27b//7b//9v///8xzLXGAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAJe0lEQVR4nO2da2ObNhiFSZosbtZ1i5vu0qTbuoXuki30si04tv//35puGLAtHwkQCHyeD05swws8Fq8ECJGsyUGSoVcgdigIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCBAQEGr2+T8Uf+92LypfP3bQ9cLfD9Lkq87DjqYoKfr064F5YngquOgfQnaIU06F5QlJ3cdh+y9BH24TJKTl/fSj0Aq+vQ6SZ59rwrX6n2SnN0pc2Jb310np/frT9diuhdiu5fz5OLTZXLyZv1hJqYqF7MJoEJqRYuZDCKWKV5FvD/EJGf3zbaiX0FZkhgxhSDziZxQTCK38LL8+Pwx11+LzRaCNJeFWk0ZoCJIfnolX26Mt/IbX8IKKjCCZCl4XH9UiULvYuKn1t6uVAq5eFylhbfz+/U/Yq4vHuVEV0rQlZw3eWOmV1QDVHYxMePJO/WVFCRK4sdk337uQK+CxNac/Wm+1YJMJkrNvvCgdiUt6MZM+Pn3SxlAfC42V78qY9Uw62K/3JQSMYkpNKkO1TTn9SpIf6IzTmqyhNoL5aYV/9e2dfVjEUCWvrV5LQVVA9STdFrUaMZM0wzebw56utbp4Fez3np71d51U/xfFSSNnv38eW4VVA1Qd5DPzDsjKC/LpBd9t4OefrosUqpDCdImlnZB1hKkCmsZbywlSH/+tsw49hykNkf/7EWS3iPImoMyVd1drSPPQVuCxPZ+o/YzVfHIrbHXYkUJOn98urXnIFstJj/+d67eR12LbZeg92WTJAftoE0OOpikq+2giiBZy98p42U7qGHDvedd7KPMQC9ko1Y1m+9NQ/gHPYP46Kv7nVrs7JdMfGQTVAlQCsore5eI97eI8jK+lnRD0u3D/tbxWh30RSQoVecqROlolizsYaciKG930GRjOoLWT69n5li/SyYkKEooCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggDdCNr0GJ+eb78tKjpVWnvcBBE0qH2vhWZF38ncdt9aGEHF3yFM+SxrdVt2vrV0tAwrKOhSwMJdWM43dzvklp3suAWxBCGy4oaZgXJQ0KWAhbtR3Bdp7ep97IL6DlcPSkEg6AgE9dpQ3Gn2xC+o34bijo/oBfVTze+2l0cjqJ+G4q6G0QjqqQRZ/4leUD8NxVgFFXegH6SPhmKsgvTtsW1H35m0oHVzR12eqYlakFZkv0Ovj4ZizILkXaM3woItxfTSUIxWkEzA2oytkXPc1fxyDu82ZkMRcNwlaL1OxUZbk4viqBuKyo/cjQ41F4+5oVgkGFt28QzXQYjIBBUJJqOg/atjEsxi1upooydBPV5irSyiHFmvk3CtQziUoH4FQTaDYdoPNo5bkMhTKEFNWRA8EFXTgHNGUxaUulRfORitccKClvMuhqqetKBGI3maKAOdMOtTEEwvfuE6CBGZIJhePMO1DxGZoE0jZ0yHGrG1g3oJR0GuIaITpIZDT9tV9lMWlJ/cZXJc/jEczXe4OOfVkeeD5JnmUZ0P6ruhKAUNdkbR2i0oEkFFCUpbDVbcRtB2iMgEmRyUtWsuTlmQbioOd0YxfkEDh6Mgx1ljFTT4sVjsggztavkjELROm5wW6uKE2VgEDddQ3A4RqaDBDjVGIuhw7w7vcA1mjVUQ7NniF675rLEKGjxcI0HhOzH4hQ7ZDbhNCepDkEPPhLDdgGMXZC77HDqaD9uJM3ZBq1ttxrbp69DdgGMXtHylT3QcaCiyBEkOnVEM2g04dkHyjKJ4zQ6eMQvZDTh6QXrrWz4+z39NHW7+jkXQMOGaaIhXUICG4ogE4UvPIRqK4xGELz0HqeZHI8jh0rO9odjijOJoBDlcemYJQpeeQzQURyPI6dJzgIbieAQNdOl5RIKGCTcaQZUMjFjMrLvhhAU59LQPcjvUaAS5XDE0ldexliCHzgvLuay/jlOQI6mo5ijoEOKA9QgF+dwLtZg9i09QuCuIFUGuFf3q1t7aHroERSEIh2s0BwWBOSgIzDFpQf5JcneOSQvaCucz4VgE4a4dHuF8JhyHoP7DUZDrhBQEJuxYUOdN6r4Ftbltrsk3reld0PaEFLR/AgoCE1AQmICCwAQUBCYILqir+j6soNCHpA4lqF9Bvj3M7D/oNAV59zDrS0Mkgpz7B9n3rAEEtcxFPvM59zBLoiacIIcSND08cxDqYTY9/ApcN/dtjoqO20HTI5ygYTPxATw3I4wda+S9n3pMGiiAHQoCUBCAggAUBKAgAAUBKAhAQQAeagAoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQoEtB+dbADWoYEH2t0W0E3VoA+VTTi31h3QLk5iLPjdca7NKhIDlKXF7ZlFxdgF08dx7sohYgFzOroYm3w3qsgQ7gsQZ76E6Q7tpQDmiuBrTyGcC7FkC/yU4ftsN6rIEZHHvwp1cb9L3Q5fhM2flbKShzLtu1AJuffTusxxqY5zK7r8E+OhSkNmnzc4m3KgelX4oE4NQXpBYgP/1rrubbCuuxBsWTUd3XYB/dCdI7f5ECZHFPVRpRllzWrxYgk/0g5YMp62E91qB4MqrHGuwjlKD6YFZOBaAu6MSUhhaCajVG00QUaBdTb0pBB8ZqsATQmUTM12IXq4425rQG+wiUpLNNK0R/51LT1gLozRTzNU/StREPG9f14ap5/QvqlXYqALUAusNo3qaaN4XGYw32EbChqIu4Wl+3FFkLIJOY2uLGDcXiP4812EOXhxqZbuhvHoqsc0Ba7mleAfKics7cDzVqATb7msca7MKDVQAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQECBmQbL/ynJ+tXj+btaim2pLYhZknmy6mCU367x5D592xCxIdpZ+dVd0Bx9oYLmoBa1TeQ+K6WTY8gGnTYlbkNqxTO9eCtpldfutyNMUZCU7/0/kaZ2DDj2DOiQxC5J9pfPTh8VM9u5lLbZLqrpKXyxm381a9ONtScyCDI1vs+gECgJQEGAEgoaFggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQH+B6CRUaFE/NTAAAAAAElFTkSuQmCC" /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">q1 =<span class="st"> </span><span class="kw">quantile</span>(xp, <span class="kw">seq</span>(<span class="fl">0.05</span>,<span class="fl">0.95</span>,<span class="fl">0.025</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(Rcpp)
<span class="kw">sourceCpp</span>(<span class="st">'/Users/Daniel/Desktop/MCMC.cpp'</span>)


y =<span class="st"> </span><span class="kw">numeric</span>(N)
<span class="kw">MCMC</span>(y, N)
<span class="kw">hist</span>(y)
yp =<span class="st"> </span>y[(burnin<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>N]
q2 =<span class="st"> </span><span class="kw">quantile</span>(yp, <span class="kw">seq</span>(<span class="fl">0.05</span>,<span class="fl">0.95</span>,<span class="fl">0.025</span>))
<span class="kw">qqplot</span>(q1,q2)
g =<span class="st"> </span><span class="cf">function</span>(x)
  x
<span class="kw">curve</span>(g, <span class="dt">from =</span> <span class="fl">0.05</span>, <span class="dt">to =</span> <span class="fl">0.95</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">'red'</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
<span class="kw">microbenchmark</span>(
  <span class="dt">x =</span> <span class="kw">RMCMC</span>(<span class="dv">1000</span>),
  <span class="kw">MCMC</span>(y,<span class="dv">1000</span>)
)</code></pre></div>
<p>I run this example in my friend’s laptop, and it cannot run in my laptop, so I will not evaluate these chunk.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
